# AIã‚¨ãƒ³ã‚¸ãƒ³è¨­è¨ˆæ›¸

**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**ä½œæˆæ—¥**: 2025å¹´11æœˆ12æ—¥  
**å¯¾è±¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: ãƒãƒ¼ãƒ‰ãƒœã‚¤ãƒ«ãƒ‰åˆ‘äº‹é¢¨ã‚²ãƒ¼ãƒ 

---

## ğŸ“‹ ç›®æ¬¡

1. [AIè¨­è¨ˆã®åŸºæœ¬æ–¹é‡](#aiè¨­è¨ˆã®åŸºæœ¬æ–¹é‡)
2. [AIã‚¿ã‚¤ãƒ—åˆ¥æˆ¦ç•¥](#aiã‚¿ã‚¤ãƒ—åˆ¥æˆ¦ç•¥)
3. [éƒ¨éšŠé…ç½®AI](#éƒ¨éšŠé…ç½®ai)
4. [æ”»æ’ƒé¸æŠAI](#æ”»æ’ƒé¸æŠai)
5. [ç‰¹æ®Šæ”»æ’ƒåˆ¤å®šAI](#ç‰¹æ®Šæ”»æ’ƒåˆ¤å®šai)
6. [ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—](#ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—)
7. [AIã®çŠ¶æ…‹ç®¡ç†](#aiã®çŠ¶æ…‹ç®¡ç†)
8. [é›£æ˜“åº¦èª¿æ•´](#é›£æ˜“åº¦èª¿æ•´)

---

## AIè¨­è¨ˆã®åŸºæœ¬æ–¹é‡

### è¨­è¨ˆåŸå‰‡

1. **æ®µéšçš„ãªé›£æ˜“åº¦è¨­è¨ˆ**
   - åˆå¿ƒè€…å‘ã‘ï¼ˆé‹ã³å±‹Aï¼‰ã‹ã‚‰ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆï¼ˆçˆ†å¼¾é­”Jï¼‰ã¾ã§
   - æ˜ç¢ºãªå¼·ã•ã®å·®ã‚’å®Ÿæ„Ÿã§ãã‚‹

2. **äººé–“ã‚‰ã—ã•ã®è¿½æ±‚**
   - å®Œå…¨ãƒ©ãƒ³ãƒ€ãƒ ã§ã¯ãªãã€æˆ¦ç•¥çš„ãªæ€è€ƒ
   - æ™‚ã€…ãƒŸã‚¹ã‚’ã™ã‚‹ï¼ˆå®Œç’§ã™ããªã„ï¼‰

3. **ãƒ•ã‚§ã‚¢ãƒã‚¹**
   - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é…ç½®æƒ…å ±ã‚’ä¸æ­£ã«åˆ©ç”¨ã—ãªã„
   - ãƒãƒ¼ãƒˆçš„ãªå‹•ãã¯ã—ãªã„

4. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**
   - æ€è€ƒæ™‚é–“ã¯1ç§’ä»¥å†…
   - è¤‡é›‘ãªè¨ˆç®—ã¯é¿ã‘ã‚‹

### AIã®æ§‹æˆè¦ç´ 

```
AIã‚¨ãƒ³ã‚¸ãƒ³
â”œâ”€â”€ éƒ¨éšŠé…ç½®AIï¼ˆæˆ¦é—˜é–‹å§‹æ™‚ï¼‰
â”‚   â”œâ”€â”€ ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
â”‚   â””â”€â”€ æˆ¦ç•¥çš„é…ç½®
â”‚
â”œâ”€â”€ æ”»æ’ƒé¸æŠAIï¼ˆæ¯ã‚¿ãƒ¼ãƒ³ï¼‰
â”‚   â”œâ”€â”€ æ¬¡ã®æ”»æ’ƒä½ç½®ã‚’æ±ºå®š
â”‚   â”œâ”€â”€ éƒ¨éšŠç™ºè¦‹æ™‚ã®è¿½è·¡
â”‚   â””â”€â”€ ãƒ‘ã‚¿ãƒ¼ãƒ³æ¢ç´¢
â”‚
â””â”€â”€ ç‰¹æ®Šæ”»æ’ƒåˆ¤å®šAI
    â”œâ”€â”€ ä½¿ç”¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ¤å®š
    â””â”€â”€ å¯¾è±¡ä½ç½®é¸æŠ
```

---

## AIã‚¿ã‚¤ãƒ—åˆ¥æˆ¦ç•¥

### balancedï¼ˆãƒãƒ©ãƒ³ã‚¹å‹ï¼‰ - é‹ã³å±‹A

**ç‰¹å¾´**:
- åŸºæœ¬çš„ãªãƒ«ãƒ¼ãƒ«ã«å¾“ã†
- éƒ¨éšŠç™ºè¦‹æ™‚ã¯è¿½è·¡ã™ã‚‹ãŒã€å®Œç’§ã§ã¯ãªã„
- ç‰¹æ®Šæ”»æ’ƒã¯ã‚ã¾ã‚Šä½¿ã‚ãªã„

**æ€è€ƒãƒ•ãƒ­ãƒ¼**:
```
ã‚¿ãƒ¼ãƒ³é–‹å§‹
  â†“
éƒ¨éšŠç™ºè¦‹æ¸ˆã¿ï¼Ÿ
  â”œâ”€ YES â†’ 50%ã®ç¢ºç‡ã§å‘¨è¾ºã‚’æ¢ç´¢
  â”‚         50%ã®ç¢ºç‡ã§ãƒ©ãƒ³ãƒ€ãƒ æ”»æ’ƒ
  â”‚
  â””â”€ NO â†’ ãƒ©ãƒ³ãƒ€ãƒ ãªæœªæ¢ç´¢ã‚»ãƒ«ã‚’æ”»æ’ƒ
```

**å®Ÿè£…**:
```typescript
function balancedAI(state: AIState): Position {
  const { lastHitPosition, discoveredCells, field } = state
  
  // å‰å›HITã—ãŸå ´æ‰€ãŒã‚ã‚‹å ´åˆã€50%ã®ç¢ºç‡ã§å‘¨è¾ºæ¢ç´¢
  if (lastHitPosition && Math.random() < 0.5) {
    const adjacentCells = getAdjacentUnexploredCells(lastHitPosition, field)
    if (adjacentCells.length > 0) {
      return randomChoice(adjacentCells)
    }
  }
  
  // ãã‚Œä»¥å¤–ã¯ãƒ©ãƒ³ãƒ€ãƒ æ”»æ’ƒ
  return getRandomUnexploredCell(field)!
}
```

---

### aggressiveï¼ˆæ”»æ’ƒå‹ï¼‰ - ç‹‚äººB

**ç‰¹å¾´**:
- HPå‰Šã‚Šã‚’å„ªå…ˆï¼ˆéƒ¨éšŠç ´å£Šã‚ˆã‚Šã‚‚ç›´æ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
- éƒ¨éšŠç™ºè¦‹æ™‚ã‚‚30%ã®ç¢ºç‡ã§ãƒ©ãƒ³ãƒ€ãƒ æ”»æ’ƒ
- ç‰¹æ®Šæ”»æ’ƒã‚’ç©æ¥µçš„ã«ä½¿ç”¨

**æ€è€ƒãƒ•ãƒ­ãƒ¼**:
```
ã‚¿ãƒ¼ãƒ³é–‹å§‹
  â†“
éƒ¨éšŠç™ºè¦‹æ¸ˆã¿ï¼Ÿ
  â”œâ”€ YES â†’ 30%ã®ç¢ºç‡ã§ãƒ©ãƒ³ãƒ€ãƒ æ”»æ’ƒï¼ˆHPç‹™ã„ï¼‰
  â”‚         70%ã®ç¢ºç‡ã§éƒ¨éšŠç ´å£Šç¶šè¡Œ
  â”‚
  â””â”€ NO â†’ ãƒ©ãƒ³ãƒ€ãƒ ãªæœªæ¢ç´¢ã‚»ãƒ«ã‚’æ”»æ’ƒ
```

**å®Ÿè£…**:
```typescript
function aggressiveAI(state: AIState): Position {
  const { lastHitPosition, field } = state
  
  // éƒ¨éšŠç™ºè¦‹æ™‚ã‚‚30%ã®ç¢ºç‡ã§HPç‹™ã„
  if (lastHitPosition && Math.random() < 0.7) {
    // éƒ¨éšŠç ´å£Šã‚’ç¶šè¡Œ
    const adjacentCells = getAdjacentUnexploredCells(lastHitPosition, field)
    if (adjacentCells.length > 0) {
      return randomChoice(adjacentCells)
    }
  }
  
  // HPå‰Šã‚Šã‚’å„ªå…ˆï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ”»æ’ƒï¼‰
  return getRandomUnexploredCell(field)!
}
```

**ç‰¹æ®Šæ”»æ’ƒã®ä½¿ç”¨æ¡ä»¶**:
```typescript
function shouldUseSpecialAttack_Aggressive(state: AIState): boolean {
  // SPãŒ60%ä»¥ä¸Šã‚ã‚Šã€ç›¸æ‰‹HPãŒ80%ä»¥ä¸‹ãªã‚‰40%ã®ç¢ºç‡ã§ä½¿ç”¨
  if (state.currentSP < state.maxSP * 0.6) return false
  if (state.enemyHP > state.enemyMaxHP * 0.8) return false
  
  return Math.random() < 0.4
}
```

---

### strategicï¼ˆæˆ¦ç•¥å‹ï¼‰ - Zå¤§ä½

**ç‰¹å¾´**:
- éƒ¨éšŠã®å½¢ã‚’æ¨æ¸¬ã—ã¦ç ´å£Š
- ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒ¼ãƒã‚’å®Ÿè¡Œï¼ˆãƒã‚§ã‚¹ç›¤çŠ¶ãªã©ï¼‰
- åŠ¹æœçš„ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ç‰¹æ®Šæ”»æ’ƒã‚’ä½¿ç”¨

**æ€è€ƒãƒ•ãƒ­ãƒ¼**:
```
ã‚¿ãƒ¼ãƒ³é–‹å§‹
  â†“
éƒ¨éšŠç™ºè¦‹æ¸ˆã¿ï¼Ÿ
  â”œâ”€ YES â†’ å½¢çŠ¶æ¨æ¸¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œ
  â”‚         â””â”€ æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„æ–¹å‘ã‚’æ”»æ’ƒ
  â”‚
  â””â”€ NO â†’ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒ¼ãƒå®Ÿè¡Œ
           â””â”€ ãƒã‚§ã‚¹ç›¤çŠ¶ã«æ¢ç´¢
```

**å®Ÿè£…**:
```typescript
function strategicAI(state: AIState): Position {
  const { lastHitPosition, discoveredCells, field } = state
  
  // éƒ¨éšŠç™ºè¦‹æ™‚ã¯å½¢çŠ¶æ¨æ¸¬
  if (lastHitPosition) {
    const predictedCells = predictUnitShape(lastHitPosition, discoveredCells, field)
    if (predictedCells.length > 0) {
      // æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„ã‚»ãƒ«ã‚’æ”»æ’ƒ
      return predictedCells[0]
    }
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒ¼ãƒï¼ˆãƒã‚§ã‚¹ç›¤çŠ¶ï¼‰
  return getNextPatternCell(state)
}

/**
 * éƒ¨éšŠã®å½¢çŠ¶ã‚’æ¨æ¸¬
 */
function predictUnitShape(
  hitPosition: Position,
  discoveredCells: Position[],
  field: Field
): Position[] {
  const candidates: Position[] = []
  const directions = [
    { x: 0, y: -1 }, // ä¸Š
    { x: 0, y: 1 },  // ä¸‹
    { x: -1, y: 0 }, // å·¦
    { x: 1, y: 0 }   // å³
  ]
  
  // éš£æ¥ã™ã‚‹æœªæ¢ç´¢ã‚»ãƒ«ã‚’ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
  for (const dir of directions) {
    const pos = {
      x: hitPosition.x + dir.x,
      y: hitPosition.y + dir.y
    }
    
    if (isValidPosition(pos, field.size) && 
        field.cells[pos.y][pos.x].state === CellState.UNEXPLORED) {
      // ãã®æ–¹å‘ã«æ—¢ã«HITãŒã‚ã‚Œã°ã‚¹ã‚³ã‚¢ãŒé«˜ã„
      const score = calculateDirectionScore(pos, dir, discoveredCells)
      candidates.push({ position: pos, score })
    }
  }
  
  // ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
  candidates.sort((a, b) => b.score - a.score)
  return candidates.map(c => c.position)
}

/**
 * ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒ¼ãƒã®æ¬¡ã®ã‚»ãƒ«ã‚’å–å¾—
 */
function getNextPatternCell(state: AIState): Position {
  const { field, patternIndex } = state
  const pattern = getCheckerboardPattern(field.size)
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¬¡ã®æœªæ¢ç´¢ã‚»ãƒ«ã‚’æ¢ã™
  for (let i = patternIndex; i < pattern.length; i++) {
    const pos = pattern[i]
    if (field.cells[pos.y][pos.x].state === CellState.UNEXPLORED) {
      state.patternIndex = i + 1
      return pos
    }
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå°½ããŸã‚‰ãƒ©ãƒ³ãƒ€ãƒ 
  return getRandomUnexploredCell(field)!
}

/**
 * ãƒã‚§ã‚¹ç›¤çŠ¶ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
 */
function getCheckerboardPattern(size: GridSize): Position[] {
  const pattern: Position[] = []
  
  for (let y = 0; y < size.height; y++) {
    for (let x = 0; x < size.width; x++) {
      // ãƒã‚§ã‚¹ç›¤çŠ¶ã«é…ç½®ï¼ˆ(x + y) % 2 === 0ï¼‰
      if ((x + y) % 2 === 0) {
        pattern.push({ x, y })
      }
    }
  }
  
  return pattern
}
```

---

### expertï¼ˆã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆï¼‰ - çˆ†å¼¾é­”J

**ç‰¹å¾´**:
- ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—ã‚’ä½œæˆã—ã¦æœ€é©ãªä½ç½®ã‚’æ”»æ’ƒ
- éƒ¨éšŠã®å¯èƒ½ãªé…ç½®ã‚’å…¨ã¦è¨ˆç®—
- é«˜åº¦ãªç‰¹æ®Šæ”»æ’ƒæˆ¦ç•¥

**æ€è€ƒãƒ•ãƒ­ãƒ¼**:
```
ã‚¿ãƒ¼ãƒ³é–‹å§‹
  â†“
ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—ã‚’ä½œæˆ
  â†“
éƒ¨éšŠç™ºè¦‹æ¸ˆã¿ï¼Ÿ
  â”œâ”€ YES â†’ ç™ºè¦‹ã—ãŸéƒ¨éšŠã®æ®‹ã‚Šã‚»ãƒ«ã‚’è¨ˆç®—
  â”‚         â””â”€ æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„ã‚»ãƒ«ã‚’æ”»æ’ƒ
  â”‚
  â””â”€ NO â†’ ç¢ºç‡ãŒæœ€ã‚‚é«˜ã„ã‚»ãƒ«ã‚’æ”»æ’ƒ
```

**å®Ÿè£…**:
```typescript
function expertAI(state: AIState): Position {
  // ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—ã‚’ä½œæˆ
  const probabilityMap = calculateProbabilityMap(state)
  
  // æœ€ã‚‚ç¢ºç‡ãŒé«˜ã„ã‚»ãƒ«ã‚’é¸æŠ
  const bestCell = getMostProbableCell(probabilityMap)
  
  return bestCell
}

/**
 * ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—ã‚’è¨ˆç®—
 */
function calculateProbabilityMap(state: AIState): number[][] {
  const { field, remainingUnits } = state
  const map: number[][] = Array(field.size.height)
    .fill(0)
    .map(() => Array(field.size.width).fill(0))
  
  // å„æœªé…ç½®éƒ¨éšŠã«ã¤ã„ã¦
  for (const unitId of remainingUnits) {
    const unit = getUnitById(unitId)
    
    // å…¨ã¦ã®é…ç½®å¯èƒ½ãªä½ç½®ãƒ»å›è»¢ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    for (let y = 0; y < field.size.height; y++) {
      for (let x = 0; x < field.size.width; x++) {
        for (const rotation of [0, 90, 180, 270]) {
          if (canPlaceUnitHere(unit, { x, y }, rotation, field)) {
            // ã“ã®é…ç½®ãŒå¯èƒ½ãªã‚‰ã€å æœ‰ã‚»ãƒ«ã®ç¢ºç‡ã‚’ä¸Šã’ã‚‹
            const occupiedCells = getOccupiedCells(unit, { x, y }, rotation)
            for (const cell of occupiedCells) {
              map[cell.y][cell.x] += 1
            }
          }
        }
      }
    }
  }
  
  // æ—¢ã«æ¢ç´¢æ¸ˆã¿ã®ã‚»ãƒ«ã¯ç¢ºç‡0
  for (let y = 0; y < field.size.height; y++) {
    for (let x = 0; x < field.size.width; x++) {
      if (field.cells[y][x].state !== CellState.UNEXPLORED) {
        map[y][x] = 0
      }
    }
  }
  
  return map
}

/**
 * æœ€ã‚‚ç¢ºç‡ãŒé«˜ã„ã‚»ãƒ«ã‚’å–å¾—
 */
function getMostProbableCell(probabilityMap: number[][]): Position {
  let maxProb = 0
  const candidates: Position[] = []
  
  for (let y = 0; y < probabilityMap.length; y++) {
    for (let x = 0; x < probabilityMap[y].length; x++) {
      if (probabilityMap[y][x] > maxProb) {
        maxProb = probabilityMap[y][x]
        candidates = [{ x, y }]
      } else if (probabilityMap[y][x] === maxProb && maxProb > 0) {
        candidates.push({ x, y })
      }
    }
  }
  
  // åŒã˜ç¢ºç‡ã®ã‚»ãƒ«ãŒè¤‡æ•°ã‚ã‚Œã°ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
  return randomChoice(candidates)
}
```

---

## éƒ¨éšŠé…ç½®AI

### ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ï¼ˆEasyï½Mediumï¼‰

**æ–¹é‡**:
- å®Œå…¨ã«ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ãƒ»å›è»¢ã§é…ç½®
- é…ç½®ã§ãã‚‹ã¾ã§è©¦è¡Œã‚’ç¹°ã‚Šè¿”ã™

**å®Ÿè£…**:
```typescript
function placeUnitsRandomly(enemy: Enemy, field: Field): PlacedUnit[] {
  const placedUnits: PlacedUnit[] = []
  
  for (const unitId of enemy.units) {
    const unit = getUnitById(unitId)
    let placed = false
    let attempts = 0
    const maxAttempts = 100
    
    while (!placed && attempts < maxAttempts) {
      // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã¨å›è»¢
      const x = Math.floor(Math.random() * field.size.width)
      const y = Math.floor(Math.random() * field.size.height)
      const rotation = randomChoice([0, 90, 180, 270])
      
      // é…ç½®å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
      if (canPlaceUnit(unit, { x, y }, rotation, field, placedUnits)) {
        const placedUnit = placeUnit(unit, { x, y }, rotation, field)
        placedUnits.push(placedUnit)
        placed = true
      }
      
      attempts++
    }
    
    // é…ç½®ã§ããªã‹ã£ãŸå ´åˆã¯è­¦å‘Š
    if (!placed) {
      console.warn(`Failed to place unit: ${unitId}`)
    }
  }
  
  return placedUnits
}
```

---

### æˆ¦ç•¥çš„é…ç½®ï¼ˆHardï½Nightmareï¼‰

**æ–¹é‡**:
- é‡è¦ãªéƒ¨éšŠï¼ˆå·¨å¤§é£›è¡Œè‰‡ã€èˆªç©ºæ¯è‰¦ï¼‰ã‚’ä¸­å¤®ã«é…ç½®
- åœ°é›·ã‚’åˆ†æ•£é…ç½®
- ç«¯ã«é…ç½®ã—ãªã„ï¼ˆè¦‹ã¤ã‹ã‚Šã«ããã™ã‚‹ï¼‰

**å®Ÿè£…**:
```typescript
function placeUnitsStrategically(enemy: Enemy, field: Field): PlacedUnit[] {
  const placedUnits: PlacedUnit[] = []
  const units = enemy.units.map(id => getUnitById(id))
  
  // å„ªå…ˆåº¦é †ã«ã‚½ãƒ¼ãƒˆï¼ˆé‡è¦ãªéƒ¨éšŠã‚’å…ˆã«é…ç½®ï¼‰
  units.sort((a, b) => getUnitPriority(b) - getUnitPriority(a))
  
  for (const unit of units) {
    let placed = false
    let attempts = 0
    const maxAttempts = 100
    
    while (!placed && attempts < maxAttempts) {
      const position = getStrategicPosition(unit, field, placedUnits)
      const rotation = randomChoice([0, 90, 180, 270])
      
      if (canPlaceUnit(unit, position, rotation, field, placedUnits)) {
        const placedUnit = placeUnit(unit, position, rotation, field)
        placedUnits.push(placedUnit)
        placed = true
      }
      
      attempts++
    }
  }
  
  return placedUnits
}

/**
 * éƒ¨éšŠã®å„ªå…ˆåº¦ã‚’å–å¾—ï¼ˆé«˜ã„ã»ã©é‡è¦ï¼‰
 */
function getUnitPriority(unit: Unit): number {
  const priorities = {
    'giant_airship': 100,
    'aircraft_carrier': 90,
    'ferrari': 80,
    'passenger_plane': 70,
    'mine': 10,
    'default': 50
  }
  
  return priorities[unit.id] || priorities.default
}

/**
 * æˆ¦ç•¥çš„ãªé…ç½®ä½ç½®ã‚’å–å¾—
 */
function getStrategicPosition(
  unit: Unit,
  field: Field,
  placedUnits: PlacedUnit[]
): Position {
  const centerX = Math.floor(field.size.width / 2)
  const centerY = Math.floor(field.size.height / 2)
  
  // é‡è¦ãªéƒ¨éšŠã¯ä¸­å¤®å¯„ã‚Šã«é…ç½®
  if (unit.id === 'giant_airship' || unit.id === 'aircraft_carrier') {
    const range = 2
    return {
      x: centerX + Math.floor(Math.random() * range * 2) - range,
      y: centerY + Math.floor(Math.random() * range * 2) - range
    }
  }
  
  // åœ°é›·ã¯åˆ†æ•£é…ç½®
  if (unit.id === 'mine') {
    return getDistributedPosition(field, placedUnits.filter(u => u.unitId === 'mine'))
  }
  
  // ãã®ä»–ã¯ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆç«¯ã¯é¿ã‘ã‚‹ï¼‰
  const margin = 1
  return {
    x: margin + Math.floor(Math.random() * (field.size.width - margin * 2)),
    y: margin + Math.floor(Math.random() * (field.size.height - margin * 2))
  }
}

/**
 * åˆ†æ•£ã—ãŸä½ç½®ã‚’å–å¾—ï¼ˆåœ°é›·ç”¨ï¼‰
 */
function getDistributedPosition(
  field: Field,
  existingMines: PlacedUnit[]
): Position {
  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’4åˆ†å‰²ã—ã¦ã€å„ã‚¨ãƒªã‚¢ã«1ã¤ãšã¤é…ç½®
  const quadrants = [
    { minX: 0, maxX: field.size.width / 2, minY: 0, maxY: field.size.height / 2 },
    { minX: field.size.width / 2, maxX: field.size.width, minY: 0, maxY: field.size.height / 2 },
    { minX: 0, maxX: field.size.width / 2, minY: field.size.height / 2, maxY: field.size.height },
    { minX: field.size.width / 2, maxX: field.size.width, minY: field.size.height / 2, maxY: field.size.height }
  ]
  
  // ã¾ã åœ°é›·ãŒå°‘ãªã„ã‚¨ãƒªã‚¢ã‚’é¸æŠ
  const quadrantCounts = quadrants.map(q => 
    existingMines.filter(m => 
      m.position.x >= q.minX && m.position.x < q.maxX &&
      m.position.y >= q.minY && m.position.y < q.maxY
    ).length
  )
  
  const minCount = Math.min(...quadrantCounts)
  const targetQuadrant = quadrants[quadrantCounts.indexOf(minCount)]
  
  return {
    x: Math.floor(targetQuadrant.minX + Math.random() * (targetQuadrant.maxX - targetQuadrant.minX)),
    y: Math.floor(targetQuadrant.minY + Math.random() * (targetQuadrant.maxY - targetQuadrant.minY))
  }
}
```

---

## æ”»æ’ƒé¸æŠAI

### å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°

```typescript
/**
 * ãƒ©ãƒ³ãƒ€ãƒ ãªæœªæ¢ç´¢ã‚»ãƒ«ã‚’å–å¾—
 */
function getRandomUnexploredCell(field: Field): Position | null {
  const unexplored: Position[] = []
  
  for (let y = 0; y < field.size.height; y++) {
    for (let x = 0; x < field.size.width; x++) {
      if (field.cells[y][x].state === CellState.UNEXPLORED) {
        unexplored.push({ x, y })
      }
    }
  }
  
  return unexplored.length > 0 ? randomChoice(unexplored) : null
}

/**
 * éš£æ¥ã™ã‚‹æœªæ¢ç´¢ã‚»ãƒ«ã‚’å–å¾—
 */
function getAdjacentUnexploredCells(
  position: Position,
  field: Field
): Position[] {
  const adjacent: Position[] = []
  const directions = [
    { x: 0, y: -1 }, // ä¸Š
    { x: 0, y: 1 },  // ä¸‹
    { x: -1, y: 0 }, // å·¦
    { x: 1, y: 0 }   // å³
  ]
  
  for (const dir of directions) {
    const pos = {
      x: position.x + dir.x,
      y: position.y + dir.y
    }
    
    if (isValidPosition(pos, field.size) &&
        field.cells[pos.y][pos.x].state === CellState.UNEXPLORED) {
      adjacent.push(pos)
    }
  }
  
  return adjacent
}

/**
 * é…åˆ—ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
 */
function randomChoice<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)]
}
```

---

## ç‰¹æ®Šæ”»æ’ƒåˆ¤å®šAI

### ä½¿ç”¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®åˆ¤å®š

```typescript
/**
 * ç‰¹æ®Šæ”»æ’ƒã‚’ä½¿ç”¨ã™ã‚‹ã‹åˆ¤å®š
 */
function shouldUseSpecialAttack(
  aiType: AIType,
  state: AIState
): boolean {
  // SPæ®‹é‡ãƒã‚§ãƒƒã‚¯ï¼ˆ50%ä»¥ä¸Šå¿…è¦ï¼‰
  if (state.currentSP < state.maxSP * 0.5) {
    return false
  }
  
  // ç›¸æ‰‹HPãƒã‚§ãƒƒã‚¯ï¼ˆ70%ä»¥ä¸‹ã§ä½¿ç”¨æ¤œè¨ï¼‰
  if (state.enemyHP > state.enemyMaxHP * 0.7) {
    return false
  }
  
  // AIã‚¿ã‚¤ãƒ—åˆ¥ã®ä½¿ç”¨ç¢ºç‡
  const useProbability = {
    [AIType.BALANCED]: 0.1,      // 10%
    [AIType.AGGRESSIVE]: 0.4,    // 40%
    [AIType.STRATEGIC]: 0.25,    // 25%
    [AIType.EXPERT]: 0.35        // 35%
  }
  
  return Math.random() < useProbability[aiType]
}

/**
 * ä½¿ç”¨ã™ã‚‹ç‰¹æ®Šæ”»æ’ƒã‚’é¸æŠ
 */
function selectSpecialAttack(state: AIState): string | null {
  const availableAttacks = state.placedUnits
    .filter(u => !u.isDestroyed && hasSpecialAttack(u.unitId))
    .map(u => ({
      unitId: u.unitId,
      spCost: getSpecialAttackCost(u.unitId, state)
    }))
    .filter(a => a.spCost <= state.currentSP)
  
  if (availableAttacks.length === 0) {
    return null
  }
  
  // ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
  return randomChoice(availableAttacks).unitId
}

/**
 * ç‰¹æ®Šæ”»æ’ƒã®å¯¾è±¡ä½ç½®ã‚’é¸æŠ
 */
function selectSpecialAttackTarget(
  attackType: SpecialAttackType,
  field: Field
): Position {
  const unexplored = getAllUnexploredCells(field)
  
  switch (attackType) {
    case SpecialAttackType.CROSS:
    case SpecialAttackType.COLUMN:
    case SpecialAttackType.ROW:
      // çˆ†æ’ƒç³»ã¯æœªæ¢ç´¢ãŒå¤šã„è¡Œ/åˆ—ã‚’ç‹™ã†
      return selectBestBombingTarget(attackType, field, unexplored)
    
    case SpecialAttackType.AUTO_DETECT:
      // èª˜å°å¼¾ã¯è‡ªå‹•ãªã®ã§ä½ç½®ä¸è¦
      return { x: 0, y: 0 }
    
    default:
      // ãã®ä»–ã¯ãƒ©ãƒ³ãƒ€ãƒ 
      return randomChoice(unexplored)
  }
}

/**
 * çˆ†æ’ƒã®æœ€é©ãªå¯¾è±¡ã‚’é¸æŠ
 */
function selectBestBombingTarget(
  attackType: SpecialAttackType,
  field: Field,
  unexplored: Position[]
): Position {
  const scores = new Map<string, number>()
  
  for (const pos of unexplored) {
    const targets = getAttackTargets(attackType, pos, field)
    const unexploredCount = targets.filter(t => 
      field.cells[t.y][t.x].state === CellState.UNEXPLORED
    ).length
    
    scores.set(`${pos.x},${pos.y}`, unexploredCount)
  }
  
  // ã‚¹ã‚³ã‚¢ãŒæœ€ã‚‚é«˜ã„ä½ç½®ã‚’é¸æŠ
  let bestPos: Position | null = null
  let bestScore = 0
  
  for (const [key, score] of scores.entries()) {
    if (score > bestScore) {
      bestScore = score
      const [x, y] = key.split(',').map(Number)
      bestPos = { x, y }
    }
  }
  
  return bestPos || randomChoice(unexplored)
}
```

---

## ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—

### ãƒãƒƒãƒ—ä½œæˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆExpert AIå°‚ç”¨ï¼‰

```typescript
/**
 * ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—ã®è©³ç´°å®Ÿè£…
 */
function calculateDetailedProbabilityMap(state: AIState): ProbabilityMap {
  const { field, remainingUnits, discoveredCells } = state
  const map: number[][] = createEmptyMap(field.size)
  
  // ã‚¹ãƒ†ãƒƒãƒ—1: å„éƒ¨éšŠã®å¯èƒ½ãªé…ç½®ã‚’è¨ˆç®—
  for (const unitId of remainingUnits) {
    const unit = getUnitById(unitId)
    const placements = getAllPossiblePlacements(unit, field, discoveredCells)
    
    // å„é…ç½®ã®ç¢ºç‡ã‚’åŠ ç®—
    for (const placement of placements) {
      const weight = calculatePlacementWeight(placement, discoveredCells)
      for (const cell of placement.occupiedCells) {
        map[cell.y][cell.x] += weight
      }
    }
  }
  
  // ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ã§èª¿æ•´
  adjustMapWithHeuristics(map, field, discoveredCells)
  
  // ã‚¹ãƒ†ãƒƒãƒ—3: æ­£è¦åŒ–
  normalizeMap(map)
  
  return map
}

/**
 * å…¨ã¦ã®å¯èƒ½ãªé…ç½®ã‚’å–å¾—
 */
function getAllPossiblePlacements(
  unit: Unit,
  field: Field,
  discoveredCells: Position[]
): Placement[] {
  const placements: Placement[] = []
  
  for (let y = 0; y < field.size.height; y++) {
    for (let x = 0; x < field.size.width; x++) {
      for (const rotation of [0, 90, 180, 270]) {
        const placement = {
          position: { x, y },
          rotation,
          occupiedCells: getOccupiedCells(unit, { x, y }, rotation)
        }
        
        // ã“ã®é…ç½®ãŒæ—¢çŸ¥ã®æƒ…å ±ã¨çŸ›ç›¾ã—ãªã„ã‹ãƒã‚§ãƒƒã‚¯
        if (isPlacementValid(placement, field, discoveredCells)) {
          placements.push(placement)
        }
      }
    }
  }
  
  return placements
}

/**
 * é…ç½®ã®é‡ã¿ã‚’è¨ˆç®—
 */
function calculatePlacementWeight(
  placement: Placement,
  discoveredCells: Position[]
): number {
  let weight = 1.0
  
  // HITã—ãŸä½ç½®ã«éš£æ¥ã—ã¦ã„ã‚Œã°é‡ã¿ã‚’å¢—ã‚„ã™
  for (const hitCell of discoveredCells.filter(c => c.isHit)) {
    for (const cell of placement.occupiedCells) {
      const distance = Math.abs(cell.x - hitCell.x) + Math.abs(cell.y - hitCell.y)
      if (distance === 1) {
        weight *= 2.0
      }
    }
  }
  
  return weight
}

/**
 * ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ã§ãƒãƒƒãƒ—ã‚’èª¿æ•´
 */
function adjustMapWithHeuristics(
  map: number[][],
  field: Field,
  discoveredCells: Position[]
): void {
  // ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯1: ç«¯ã®ã‚»ãƒ«ã¯ç¢ºç‡ã‚’ä¸‹ã’ã‚‹
  for (let y = 0; y < field.size.height; y++) {
    for (let x = 0; x < field.size.width; x++) {
      const isEdge = x === 0 || x === field.size.width - 1 ||
                     y === 0 || y === field.size.height - 1
      if (isEdge) {
        map[y][x] *= 0.8
      }
    }
  }
  
  // ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯2: HITã®å‘¨è¾ºã¯ç¢ºç‡ã‚’ä¸Šã’ã‚‹
  for (const hitCell of discoveredCells.filter(c => c.isHit)) {
    const adjacent = getAdjacentUnexploredCells(hitCell, field)
    for (const cell of adjacent) {
      map[cell.y][cell.x] *= 1.5
    }
  }
}

/**
 * ãƒãƒƒãƒ—ã‚’æ­£è¦åŒ–
 */
function normalizeMap(map: number[][]): void {
  let max = 0
  
  for (const row of map) {
    for (const value of row) {
      max = Math.max(max, value)
    }
  }
  
  if (max === 0) return
  
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      map[y][x] /= max
    }
  }
}
```

---

## AIã®çŠ¶æ…‹ç®¡ç†

### AIState ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
interface AIState {
  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æƒ…å ±
  field: Field
  
  // ç¾åœ¨ã®çŠ¶æ…‹
  currentHP: number
  maxHP: number
  currentSP: number
  maxSP: number
  
  // æ•µï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰æƒ…å ±
  enemyHP: number
  enemyMaxHP: number
  
  // é…ç½®éƒ¨éšŠ
  placedUnits: PlacedUnit[]
  remainingUnits: string[]  // ã¾ã ç™ºè¦‹ã•ã‚Œã¦ã„ãªã„éƒ¨éšŠ
  
  // æ”»æ’ƒå±¥æ­´
  lastHitPosition?: Position
  discoveredCells: DiscoveredCell[]
  
  // AIæˆ¦ç•¥ç”¨
  patternIndex: number  // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒ¼ãƒã®é€²è¡ŒçŠ¶æ³
  consecutiveMisses: number  // é€£ç¶šMISSå›æ•°
}

interface DiscoveredCell {
  position: Position
  isHit: boolean
  unitId?: string
}
```

### çŠ¶æ…‹æ›´æ–°

```typescript
/**
 * æ”»æ’ƒçµæœã«åŸºã¥ã„ã¦AIçŠ¶æ…‹ã‚’æ›´æ–°
 */
function updateAIState(
  state: AIState,
  attackResult: AttackResult
): void {
  const { position, isHit, unitId } = attackResult
  
  // ç™ºè¦‹æ¸ˆã¿ã‚»ãƒ«ã«è¿½åŠ 
  state.discoveredCells.push({
    position,
    isHit,
    unitId
  })
  
  // HITæ™‚ã¯æœ€å¾Œã®HITä½ç½®ã‚’æ›´æ–°
  if (isHit) {
    state.lastHitPosition = position
    state.consecutiveMisses = 0
    
    // éƒ¨éšŠãŒç ´å£Šã•ã‚ŒãŸã‚‰æ®‹å­˜éƒ¨éšŠã‹ã‚‰å‰Šé™¤
    if (unitId) {
      const index = state.remainingUnits.indexOf(unitId)
      if (index !== -1) {
        state.remainingUnits.splice(index, 1)
      }
    }
  } else {
    state.consecutiveMisses++
    
    // é€£ç¶šMISSãŒå¤šã„å ´åˆã¯æˆ¦ç•¥ã‚’å¤‰æ›´
    if (state.consecutiveMisses > 5) {
      state.lastHitPosition = undefined
    }
  }
}
```

---

## é›£æ˜“åº¦èª¿æ•´

### é›£æ˜“åº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

```typescript
interface DifficultyParams {
  // æ€è€ƒæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
  thinkingTime: number
  
  // ãƒŸã‚¹ã®ç¢ºç‡ï¼ˆ0.0ï½1.0ï¼‰
  mistakeProbability: number
  
  // ç‰¹æ®Šæ”»æ’ƒä½¿ç”¨ç¢ºç‡
  specialAttackRate: number
  
  // é…ç½®æˆ¦ç•¥
  placementStrategy: 'random' | 'strategic'
}

const difficultySettings: Record<AIType, DifficultyParams> = {
  [AIType.BALANCED]: {
    thinkingTime: 800,
    mistakeProbability: 0.3,
    specialAttackRate: 0.1,
    placementStrategy: 'random'
  },
  [AIType.AGGRESSIVE]: {
    thinkingTime: 600,
    mistakeProbability: 0.2,
    specialAttackRate: 0.4,
    placementStrategy: 'random'
  },
  [AIType.STRATEGIC]: {
    thinkingTime: 1000,
    mistakeProbability: 0.1,
    specialAttackRate: 0.25,
    placementStrategy: 'strategic'
  },
  [AIType.EXPERT]: {
    thinkingTime: 1200,
    mistakeProbability: 0.05,
    specialAttackRate: 0.35,
    placementStrategy: 'strategic'
  }
}
```

### æ„å›³çš„ãªãƒŸã‚¹ã®å®Ÿè£…

```typescript
/**
 * é›£æ˜“åº¦ã«å¿œã˜ã¦æ„å›³çš„ã«ãƒŸã‚¹ã‚’ã•ã›ã‚‹
 */
function applyMistakeProbability(
  optimalPosition: Position,
  field: Field,
  mistakeProbability: number
): Position {
  if (Math.random() < mistakeProbability) {
    // ãƒŸã‚¹ã‚’ã™ã‚‹å ´åˆã¯æœ€é©è§£ã®è¿‘ãã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
    const nearbyUnexplored = getNearbyUnexploredCells(optimalPosition, field, 2)
    if (nearbyUnexplored.length > 0) {
      return randomChoice(nearbyUnexplored)
    }
  }
  
  return optimalPosition
}

/**
 * è¿‘ãã®æœªæ¢ç´¢ã‚»ãƒ«ã‚’å–å¾—
 */
function getNearbyUnexploredCells(
  center: Position,
  field: Field,
  radius: number
): Position[] {
  const nearby: Position[] = []
  
  for (let dy = -radius; dy <= radius; dy++) {
    for (let dx = -radius; dx <= radius; dx++) {
      if (dx === 0 && dy === 0) continue
      
      const pos = { x: center.x + dx, y: center.y + dy }
      if (isValidPosition(pos, field.size) &&
          field.cells[pos.y][pos.x].state === CellState.UNEXPLORED) {
        nearby.push(pos)
      }
    }
  }
  
  return nearby
}
```

---

## AIã‚¿ãƒ¼ãƒ³å®Ÿè¡Œãƒ•ãƒ­ãƒ¼

### ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼

```typescript
/**
 * AIã®ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿè¡Œ
 */
async function executeAITurn(state: BattleState): Promise<void> {
  const aiType = state.enemy.aiType
  const difficulty = difficultySettings[aiType]
  
  // æ€è€ƒæ™‚é–“ã‚’æ¼”å‡º
  await sleep(difficulty.thinkingTime)
  
  // ç‰¹æ®Šæ”»æ’ƒåˆ¤å®š
  if (shouldUseSpecialAttack(aiType, createAIState(state))) {
    const attackUnit = selectSpecialAttack(createAIState(state))
    if (attackUnit) {
      const target = selectSpecialAttackTarget(
        getSpecialAttackType(attackUnit),
        state.playerField
      )
      await executeSpecialAttack(attackUnit, target, state)
      return
    }
  }
  
  // é€šå¸¸æ”»æ’ƒ
  const aiState = createAIState(state)
  let targetPosition: Position
  
  switch (aiType) {
    case AIType.BALANCED:
      targetPosition = balancedAI(aiState)
      break
    case AIType.AGGRESSIVE:
      targetPosition = aggressiveAI(aiState)
      break
    case AIType.STRATEGIC:
      targetPosition = strategicAI(aiState)
      break
    case AIType.EXPERT:
      targetPosition = expertAI(aiState)
      break
  }
  
  // æ„å›³çš„ãªãƒŸã‚¹ã‚’é©ç”¨
  targetPosition = applyMistakeProbability(
    targetPosition,
    state.playerField,
    difficulty.mistakeProbability
  )
  
  // æ”»æ’ƒå®Ÿè¡Œ
  const result = await executeAttack(targetPosition, state)
  
  // AIçŠ¶æ…‹æ›´æ–°
  updateAIState(aiState, result)
  
  // å‹æ•—åˆ¤å®š
  const winner = checkVictory(state)
  if (winner) {
    endBattle(state, winner)
  }
}

/**
 * ã‚¹ãƒªãƒ¼ãƒ—é–¢æ•°
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}
```

---

## ãƒ†ã‚¹ãƒˆãƒ»ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½

### AIæ€è€ƒã®å¯è¦–åŒ–

```typescript
/**
 * AIæ€è€ƒéç¨‹ã‚’ãƒ­ã‚°å‡ºåŠ›ï¼ˆé–‹ç™ºç”¨ï¼‰
 */
function logAIThinking(
  aiType: AIType,
  targetPosition: Position,
  reason: string
): void {
  if (process.env.NODE_ENV === 'development') {
    console.log(`[AI:${aiType}] Target: (${targetPosition.x}, ${targetPosition.y})`)
    console.log(`[AI:${aiType}] Reason: ${reason}`)
  }
}

/**
 * ç¢ºç‡åˆ†å¸ƒãƒãƒƒãƒ—ã‚’å¯è¦–åŒ–ï¼ˆé–‹ç™ºç”¨ï¼‰
 */
function visualizeProbabilityMap(map: number[][]): void {
  if (process.env.NODE_ENV === 'development') {
    console.table(map.map(row => 
      row.map(v => Math.round(v * 100))
    ))
  }
}
```

---

**ä»¥ä¸Šã€AIã‚¨ãƒ³ã‚¸ãƒ³è¨­è¨ˆæ›¸ï¼ˆç¬¬1ç‰ˆï¼‰**
