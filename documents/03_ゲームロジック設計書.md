# ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯è¨­è¨ˆæ›¸

**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0  
**ä½œæˆæ—¥**: 2025å¹´11æœˆ12æ—¥  
**æ›´æ–°æ—¥**: 2025å¹´11æœˆ13æ—¥  
**å¯¾è±¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: ãƒãƒ¼ãƒ‰ãƒœã‚¤ãƒ«ãƒ‰åˆ‘äº‹é¢¨ã‚²ãƒ¼ãƒ 

---

## ğŸ“‹ ç›®æ¬¡

1. [ã‚°ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ ](#ã‚°ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ )
2. [éƒ¨éšŠé…ç½®ãƒ­ã‚¸ãƒƒã‚¯](#éƒ¨éšŠé…ç½®ãƒ­ã‚¸ãƒƒã‚¯)
3. [æˆ¦é—˜ãƒ•ãƒ­ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯](#æˆ¦é—˜ãƒ•ãƒ­ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯)
4. [æ”»æ’ƒåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯](#æ”»æ’ƒåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯)
5. [ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯](#ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯)
6. [ç‰¹æ®Šæ”»æ’ƒãƒ­ã‚¸ãƒƒã‚¯](#ç‰¹æ®Šæ”»æ’ƒãƒ­ã‚¸ãƒƒã‚¯)
7. [åœ°é›·ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯](#åœ°é›·ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯)
8. [å‹æ•—åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯](#å‹æ•—åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯)
9. [çµŒé¨“å€¤ãƒ»å ±é…¬è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯](#çµŒé¨“å€¤å ±é…¬è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯)

---

## ã‚°ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ 

### ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºæ±ºå®šãƒ­ã‚¸ãƒƒã‚¯

#### ARãƒ¬ãƒ™ãƒ«ã‹ã‚‰ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã¸ã®å¤‰æ›

```typescript
/**
 * ARãƒ¬ãƒ™ãƒ«ã‹ã‚‰ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
 * @param arLevel - ARãƒ¬ãƒ™ãƒ«ï¼ˆ1ï½11ï¼‰
 * @returns GridSize - ã‚°ãƒªãƒƒãƒ‰ã®å¹…ã¨é«˜ã•
 */
function getGridSizeFromAR(arLevel: number): GridSize {
  // åŸºæœ¬ã‚µã‚¤ã‚º: 7x7
  const baseWidth = 7
  const baseHeight = 7
  
  // ARãƒ¬ãƒ™ãƒ«1ãŒåŸºæº–
  if (arLevel === 1) {
    return { width: baseWidth, height: baseHeight }
  }
  
  // ARãƒ¬ãƒ™ãƒ«2ä»¥é™ã¯äº¤äº’ã«æ¨ªãƒ»ç¸¦ã‚’æ‹¡å¼µ
  let width = baseWidth
  let height = baseHeight
  
  for (let level = 2; level <= arLevel; level++) {
    // å¶æ•°ãƒ¬ãƒ™ãƒ«: æ¨ªæ–¹å‘æ‹¡å¼µ
    if (level % 2 === 0) {
      width++
    }
    // å¥‡æ•°ãƒ¬ãƒ™ãƒ«: ç¸¦æ–¹å‘æ‹¡å¼µ
    else {
      height++
    }
  }
  
  return { width, height }
}

// ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
// AR 1: 7x7 (49ãƒã‚¹)
// AR 2: 8x7 (56ãƒã‚¹)
// AR 3: 8x8 (64ãƒã‚¹)
// AR 4: 9x8 (72ãƒã‚¹)
// AR 11: 12x12 (144ãƒã‚¹)
```

### ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆæœŸåŒ–

```typescript
/**
 * ç©ºã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç”Ÿæˆ
 * @param width - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ¨ªå¹…
 * @param height - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç¸¦å¹…
 * @returns Field - åˆæœŸåŒ–ã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 */
function createEmptyField(width: number, height: number): Field {
  const cells: Cell[][] = []
  
  for (let y = 0; y < height; y++) {
    cells[y] = []
    for (let x = 0; x < width; x++) {
      cells[y][x] = {
        position: { x, y },
        state: CellState.UNEXPLORED,
        unitId: undefined,
        isRevealed: false
      }
    }
  }
  
  return {
    size: { width, height },
    cells,
    placedUnits: []
  }
}
```

### åº§æ¨™ã®æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯

```typescript
/**
 * æŒ‡å®šåº§æ¨™ãŒãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å†…ã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
 * @param position - ãƒã‚§ãƒƒã‚¯ã™ã‚‹åº§æ¨™
 * @param fieldSize - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚µã‚¤ã‚º
 * @returns boolean - æœ‰åŠ¹ãªã‚‰true
 */
function isValidPosition(position: Position, fieldSize: GridSize): boolean {
  return (
    position.x >= 0 &&
    position.x < fieldSize.width &&
    position.y >= 0 &&
    position.y < fieldSize.height
  )
}
```

---

## éƒ¨éšŠé…ç½®ãƒ­ã‚¸ãƒƒã‚¯

### éƒ¨éšŠã®å›è»¢å‡¦ç†

```typescript
/**
 * éƒ¨éšŠã®å½¢çŠ¶ã‚’å›è»¢
 * @param shape - å…ƒã®å½¢çŠ¶ï¼ˆ2æ¬¡å…ƒé…åˆ—ï¼‰
 * @param rotation - å›è»¢è§’åº¦ï¼ˆ0, 90, 180, 270ï¼‰
 * @returns UnitShape - å›è»¢å¾Œã®å½¢çŠ¶
 */
function rotateUnitShape(shape: UnitShape, rotation: Rotation): UnitShape {
  if (rotation === Rotation.DEG_0) {
    return shape
  }
  
  let rotated = shape
  const times = rotation / 90
  
  for (let i = 0; i < times; i++) {
    rotated = rotateCW90(rotated)
  }
  
  return rotated
}

/**
 * å½¢çŠ¶ã‚’æ™‚è¨ˆå›ã‚Šã«90åº¦å›è»¢
 * @param shape - å…ƒã®å½¢çŠ¶
 * @returns UnitShape - å›è»¢å¾Œã®å½¢çŠ¶
 */
function rotateCW90(shape: UnitShape): UnitShape {
  const rows = shape.length
  const cols = shape[0].length
  const rotated: UnitShape = []
  
  for (let x = 0; x < cols; x++) {
    rotated[x] = []
    for (let y = rows - 1; y >= 0; y--) {
      rotated[x][rows - 1 - y] = shape[y][x]
    }
  }
  
  return rotated
}

// ä¾‹: æ•‘æ€¥ãƒ˜ãƒªã®å›è»¢
// å…ƒã®å½¢çŠ¶ï¼ˆ0åº¦ï¼‰:
// [[1, 0],
//  [1, 1]]
//
// 90åº¦å›è»¢:
// [[1, 1],
//  [0, 1]]
//
// 180åº¦å›è»¢:
// [[1, 1],
//  [0, 1]]
//
// 270åº¦å›è»¢:
// [[1, 0],
//  [1, 1]]
```

### å æœ‰ã‚»ãƒ«ã®è¨ˆç®—

```typescript
/**
 * éƒ¨éšŠãŒå æœ‰ã™ã‚‹ã‚»ãƒ«ã®åº§æ¨™ãƒªã‚¹ãƒˆã‚’å–å¾—
 * @param unit - éƒ¨éšŠãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
 * @param position - é…ç½®ä½ç½®ï¼ˆå·¦ä¸Šã®åº§æ¨™ï¼‰
 * @param rotation - å›è»¢è§’åº¦
 * @returns Position[] - å æœ‰ã™ã‚‹ã‚»ãƒ«ã®åº§æ¨™é…åˆ—
 */
function getOccupiedCells(
  unit: Unit,
  position: Position,
  rotation: Rotation
): Position[] {
  const rotatedShape = rotateUnitShape(unit.shape, rotation)
  const occupied: Position[] = []
  
  for (let y = 0; y < rotatedShape.length; y++) {
    for (let x = 0; x < rotatedShape[y].length; x++) {
      if (rotatedShape[y][x] === 1) {
        occupied.push({
          x: position.x + x,
          y: position.y + y
        })
      }
    }
  }
  
  return occupied
}
```

### é…ç½®å¯èƒ½æ€§ã®åˆ¤å®š

```typescript
/**
 * æŒ‡å®šä½ç½®ã«éƒ¨éšŠã‚’é…ç½®å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
 * @param unit - é…ç½®ã™ã‚‹éƒ¨éšŠ
 * @param position - é…ç½®ä½ç½®
 * @param rotation - å›è»¢è§’åº¦
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @param placedUnits - æ—¢ã«é…ç½®æ¸ˆã¿ã®éƒ¨éšŠãƒªã‚¹ãƒˆ
 * @returns boolean - é…ç½®å¯èƒ½ãªã‚‰true
 */
function canPlaceUnit(
  unit: Unit,
  position: Position,
  rotation: Rotation,
  field: Field,
  placedUnits: PlacedUnit[]
): boolean {
  // 1. å æœ‰ã‚»ãƒ«ã‚’å–å¾—
  const occupiedCells = getOccupiedCells(unit, position, rotation)
  
  // 2. ã™ã¹ã¦ã®ã‚»ãƒ«ãŒãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å†…ã‹ãƒã‚§ãƒƒã‚¯
  for (const cell of occupiedCells) {
    if (!isValidPosition(cell, field.size)) {
      return false
    }
  }
  
  // 3. æ—¢å­˜ã®éƒ¨éšŠã¨é‡ãªã£ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
  for (const placedUnit of placedUnits) {
    for (const occupiedCell of occupiedCells) {
      for (const existingCell of placedUnit.occupiedCells) {
        if (
          occupiedCell.x === existingCell.x &&
          occupiedCell.y === existingCell.y
        ) {
          return false  // é‡è¤‡ã‚ã‚Š
        }
      }
    }
  }
  
  // 4. åŒã˜éƒ¨éšŠãŒæ—¢ã«é…ç½®ã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆåœ°é›·ã¯é™¤å¤–ï¼‰
  if (unit.id !== 'mine') {
    const alreadyPlaced = placedUnits.some(u => u.unitId === unit.id)
    if (alreadyPlaced) {
      return false
    }
  }
  
  // 5. åœ°é›·ã®å ´åˆã¯æœ€å¤§6å€‹ã¾ã§
  if (unit.id === 'mine') {
    const mineCount = placedUnits.filter(u => u.unitId === 'mine').length
    if (mineCount >= 6) {
      return false
    }
  }
  
  return true
}
```

### éƒ¨éšŠé…ç½®ã®å®Ÿè¡Œ

```typescript
/**
 * éƒ¨éšŠã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é…ç½®
 * @param unit - é…ç½®ã™ã‚‹éƒ¨éšŠ
 * @param position - é…ç½®ä½ç½®
 * @param rotation - å›è»¢è§’åº¦
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns PlacedUnit - é…ç½®ã•ã‚ŒãŸéƒ¨éšŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function placeUnit(
  unit: Unit,
  position: Position,
  rotation: Rotation,
  field: Field
): PlacedUnit {
  const occupiedCells = getOccupiedCells(unit, position, rotation)
  
  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚»ãƒ«ã‚’æ›´æ–°
  for (const cell of occupiedCells) {
    field.cells[cell.y][cell.x].unitId = unit.id
  }
  
  // PlacedUnitã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
  const placedUnit: PlacedUnit = {
    unitId: unit.id,
    position,
    rotation,
    occupiedCells,
    hitCells: [],
    isDestroyed: false
  }
  
  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®é…ç½®ãƒªã‚¹ãƒˆã«è¿½åŠ 
  field.placedUnits.push(placedUnit)
  
  return placedUnit
}
```

---

## æˆ¦é—˜ãƒ•ãƒ­ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯

### å…ˆåˆ¶æ”»æ’ƒåˆ¤å®š

```typescript
/**
 * ã©ã¡ã‚‰ãŒå…ˆåˆ¶æ”»æ’ƒã™ã‚‹ã‹åˆ¤å®š
 * @param playerAR - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®AR
 * @param enemyAR - æ•µã®AR
 * @param playerUnits - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é…ç½®éƒ¨éšŠ
 * @param enemyUnits - æ•µã®é…ç½®éƒ¨éšŠ
 * @returns Turn - å…ˆæ”»ã‚¿ãƒ¼ãƒ³
 */
function determineFirstStrike(
  playerAR: number,
  enemyAR: number,
  playerUnits: PlacedUnit[],
  enemyUnits: PlacedUnit[]
): Turn {
  // ãƒ•ã‚§ãƒ©ãƒ¼ãƒªã¾ãŸã¯å·¨å¤§é£›è¡Œè‰‡ã‚’æŒã£ã¦ã„ã‚‹ã‹ç¢ºèª
  const playerHasFirstStrikeUnit = playerUnits.some(u => 
    u.unitId === 'ferrari' || u.unitId === 'giant_airship'
  )
  const enemyHasFirstStrikeUnit = enemyUnits.some(u => 
    u.unitId === 'ferrari' || u.unitId === 'giant_airship'
  )
  
  // ä¸¡æ–¹ãŒå…ˆåˆ¶éƒ¨éšŠã‚’æŒã£ã¦ã„ã‚‹å ´åˆã¯ARã§åˆ¤å®š
  if (playerHasFirstStrikeUnit && enemyHasFirstStrikeUnit) {
    return playerAR >= enemyAR ? Turn.PLAYER : Turn.ENEMY
  }
  
  // ã©ã¡ã‚‰ã‹ãŒå…ˆåˆ¶éƒ¨éšŠã‚’æŒã£ã¦ã„ã‚‹å ´åˆ
  if (playerHasFirstStrikeUnit) return Turn.PLAYER
  if (enemyHasFirstStrikeUnit) return Turn.ENEMY
  
  // ã©ã¡ã‚‰ã‚‚æŒã£ã¦ã„ãªã„å ´åˆã¯ARã§åˆ¤å®š
  return playerAR >= enemyAR ? Turn.PLAYER : Turn.ENEMY
}
```

### æˆ¦é—˜åˆæœŸåŒ–å‡¦ç†

```typescript
/**
 * æˆ¦é—˜ã‚’åˆæœŸåŒ–
 * @param player - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿
 * @param enemy - æ•µãƒ‡ãƒ¼ã‚¿
 * @param playerUnits - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é…ç½®æ¸ˆã¿éƒ¨éšŠ
 * @returns BattleState - åˆæœŸåŒ–ã•ã‚ŒãŸæˆ¦é—˜çŠ¶æ…‹
 */
function initializeBattle(
  player: Player,
  enemy: Enemy,
  playerUnits: PlacedUnit[]
): BattleState {
  // 1. ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç”Ÿæˆ
  const playerFieldSize = getGridSizeFromAR(player.stats.AR)
  const enemyFieldSize = getGridSizeFromAR(enemy.stats.AR)
  
  const playerField = createEmptyField(playerFieldSize.width, playerFieldSize.height)
  const enemyField = createEmptyField(enemyFieldSize.width, enemyFieldSize.height)
  
  // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼éƒ¨éšŠã‚’é…ç½®
  playerField.placedUnits = playerUnits
  for (const unit of playerUnits) {
    for (const cell of unit.occupiedCells) {
      playerField.cells[cell.y][cell.x].unitId = unit.unitId
    }
  }
  
  // 3. æ•µéƒ¨éšŠã‚’AIã§é…ç½®
  const enemyPlacedUnits = placeEnemyUnitsAI(enemy, enemyField)
  
  // 4. å…ˆåˆ¶æ”»æ’ƒåˆ¤å®š
  const firstTurn = determineFirstStrike(
    player.stats.AR,
    enemy.stats.AR,
    playerUnits,
    enemyPlacedUnits
  )
  
  // 5. æˆ¦é—˜çŠ¶æ…‹ã‚’ç”Ÿæˆ
  return {
    phase: BattlePhase.BATTLE,
    turn: firstTurn,
    playerField,
    enemyField,
    playerStats: { ...player.stats },
    enemyStats: { ...enemy.stats },
    enemy,
    attackHistory: [],
    canContinueAttack: false,
    consecutiveHits: 0,
    activeSpecialAttack: {
      type: null
    },
    specialAttackUsageCount: {
      player: {},
      enemy: {}
    },
    battleResult: null,
    isAnimating: false,
    currentAnimation: {
      type: null
    }
  }
}
```

### ã‚¿ãƒ¼ãƒ³äº¤ä»£ãƒ­ã‚¸ãƒƒã‚¯

```typescript
/**
 * ã‚¿ãƒ¼ãƒ³ã‚’äº¤ä»£
 * @param currentTurn - ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³
 * @returns Turn - æ¬¡ã®ã‚¿ãƒ¼ãƒ³
 */
function switchTurn(currentTurn: Turn): Turn {
  return currentTurn === Turn.PLAYER ? Turn.ENEMY : Turn.PLAYER
}

/**
 * é€£ç¶šæ”»æ’ƒå¯èƒ½ãªçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
 */
function resetContinueAttack(state: BattleState): void {
  state.canContinueAttack = false
  state.consecutiveHits = 0
}
```

---

## æ”»æ’ƒåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯

### HIT/MISSåˆ¤å®š

```typescript
/**
 * æŒ‡å®šåº§æ¨™ã¸ã®æ”»æ’ƒãŒHITã‹MISSã‹åˆ¤å®š
 * @param position - æ”»æ’ƒåº§æ¨™
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns boolean - HITãªã‚‰trueã€MISSãªã‚‰false
 */
function isHit(position: Position, field: Field): boolean {
  const cell = field.cells[position.y][position.x]
  
  // 1. ãã®ã‚»ãƒ«ã«éƒ¨éšŠãŒé…ç½®ã•ã‚Œã¦ã„ã‚‹ã‹
  if (!cell.unitId) {
    return false  // MISS
  }
  
  // 2. ãã®ã‚»ãƒ«ãŒæ—¢ã«æ”»æ’ƒæ¸ˆã¿ã‹
  if (cell.state !== CellState.UNEXPLORED) {
    return false  // æ—¢ã«æ”»æ’ƒæ¸ˆã¿
  }
  
  return true  // HIT
}
```

### HITå‡¦ç†

```typescript
/**
 * HITæ™‚ã®å‡¦ç†
 * @param position - æ”»æ’ƒåº§æ¨™
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns HitResult - HITçµæœæƒ…å ±
 */
interface HitResult {
  unitId: string
  isDestroyed: boolean
  isLandmine: boolean
}

function processHit(position: Position, field: Field): HitResult {
  const cell = field.cells[position.y][position.x]
  const unitId = cell.unitId!
  
  // 1. ã‚»ãƒ«ã®çŠ¶æ…‹ã‚’æ›´æ–°
  cell.state = CellState.HIT
  
  // 2. å¯¾å¿œã™ã‚‹éƒ¨éšŠã‚’æ¢ã™
  const placedUnit = field.placedUnits.find(u => u.unitId === unitId)
  if (!placedUnit) {
    throw new Error(`Unit not found: ${unitId}`)
  }
  
  // 3. hitCellsã«è¿½åŠ 
  placedUnit.hitCells.push(position)
  
  // 4. éƒ¨éšŠç ´å£Šåˆ¤å®š
  const isDestroyed = checkUnitDestroyed(placedUnit)
  if (isDestroyed) {
    placedUnit.isDestroyed = true
    // ã™ã¹ã¦ã®ã‚»ãƒ«ã‚’DESTROYEDçŠ¶æ…‹ã«
    for (const cell of placedUnit.occupiedCells) {
      field.cells[cell.y][cell.x].state = CellState.DESTROYED
    }
  }
  
  // 5. åœ°é›·åˆ¤å®š
  const isLandmine = unitId === 'mine'
  
  return {
    unitId,
    isDestroyed,
    isLandmine
  }
}
```

### MISSå‡¦ç†

```typescript
/**
 * MISSæ™‚ã®å‡¦ç†
 * @param position - æ”»æ’ƒåº§æ¨™
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 */
function processMiss(position: Position, field: Field): void {
  const cell = field.cells[position.y][position.x]
  cell.state = CellState.MISS
}
```

### éƒ¨éšŠç ´å£Šåˆ¤å®š

```typescript
/**
 * éƒ¨éšŠãŒå®Œå…¨ã«ç ´å£Šã•ã‚ŒãŸã‹åˆ¤å®š
 * @param placedUnit - é…ç½®æ¸ˆã¿éƒ¨éšŠ
 * @returns boolean - ç ´å£Šã•ã‚Œã¦ã„ã‚Œã°true
 */
function checkUnitDestroyed(placedUnit: PlacedUnit): boolean {
  // å æœ‰ã‚»ãƒ«æ•°ã¨ãƒ’ãƒƒãƒˆã‚»ãƒ«æ•°ã‚’æ¯”è¼ƒ
  return placedUnit.hitCells.length === placedUnit.occupiedCells.length
}
```

### æ”»æ’ƒãƒ¡ã‚¤ãƒ³å‡¦ç†

```typescript
/**
 * æ”»æ’ƒå‡¦ç†ã®ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
 * @param position - æ”»æ’ƒåº§æ¨™
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @returns AttackResult - æ”»æ’ƒçµæœ
 */
function executeAttack(position: Position, state: BattleState): AttackResult {
  // 1. æ”»æ’ƒå¯¾è±¡ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å–å¾—
  const targetField = state.turn === Turn.PLAYER ? state.enemyField : state.playerField
  const attacker = state.turn === Turn.PLAYER ? 'player' : 'enemy'
  const defender = state.turn === Turn.PLAYER ? 'enemy' : 'player'
  
  // 2. HIT/MISSåˆ¤å®š
  const hit = isHit(position, targetField)
  
  if (hit) {
    // 3a. HITå‡¦ç†
    const hitResult = processHit(position, targetField)
    
    // 4a. åœ°é›·åˆ¤å®š
    if (hitResult.isLandmine) {
      // åœ°é›·ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼æ”»æ’ƒ
      triggerLandmineCounter(attacker, state)
      
      return {
        success: true,
        isHit: true,
        destroyedUnitId: hitResult.unitId,
        canContinue: false  // åœ°é›·ã¯å¼·åˆ¶ã‚¿ãƒ¼ãƒ³äº¤ä»£
      }
    }
    
    // 4b. éƒ¨éšŠç ´å£Šæ™‚ã¯çµŒé¨“å€¤ä»˜ä¸ï¼ˆåœ°é›·ä»¥å¤–ï¼‰
    if (hitResult.isDestroyed) {
      const exp = calculateDestroyExp(hitResult.unitId)
      if (attacker === 'player') {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«çµŒé¨“å€¤ä»˜ä¸ï¼ˆå®Ÿéš›ã¯storeã§å‡¦ç†ï¼‰
      }
    }
    
    // 5a. é€£ç¶šæ”»æ’ƒå¯èƒ½
    state.canContinueAttack = true
    state.consecutiveHits++
    
    return {
      success: true,
      isHit: true,
      destroyedUnitId: hitResult.isDestroyed ? hitResult.unitId : undefined,
      canContinue: true
    }
    
  } else {
    // 3b. MISSå‡¦ç†
    processMiss(position, targetField)
    
    // 4b. ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
    const damage = calculateDirectDamage(attacker, state)
    
    // 5b. ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨
    applyDirectDamage(defender, damage, state)
    
    // 6b. ã‚¿ãƒ¼ãƒ³äº¤ä»£
    state.turn = switchTurn(state.turn)
    resetContinueAttack(state)
    
    return {
      success: true,
      isHit: false,
      damage,
      canContinue: false
    }
  }
}
```

---

## ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯

### ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è£œæ­£ã®è¨ˆç®—

```typescript
/**
 * æ”»æ’ƒåŠ›è£œæ­£ã‚’è¨ˆç®—
 * @param placedUnits - é…ç½®éƒ¨éšŠãƒªã‚¹ãƒˆ
 * @returns number - æ”»æ’ƒåŠ›ã®è£œæ­£å€ç‡
 */
function calculateAttackBonus(placedUnits: PlacedUnit[]): number {
  let bonus = 0
  
  // çŸ³æ²¹ã‚¿ãƒ³ã‚«ãƒ¼: +30%
  if (placedUnits.some(u => u.unitId === 'oil_tanker' && !u.isDestroyed)) {
    bonus += 0.3
  }
  
  // M4æˆ¦è»Š: +50%
  if (placedUnits.some(u => u.unitId === 'm4_tank' && !u.isDestroyed)) {
    bonus += 0.5
  }
  
  // å·¨å¤§é£›è¡Œè‰‡: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹UPåŠ¹æœå€¤ã‚’2å€ã«ï¼ˆä¾‹ï¼š30%â†’60%ï¼‰
  const hasGiantAirship = placedUnits.some(u => u.unitId === 'giant_airship' && !u.isDestroyed)
  const hasAtkBuffUnit = placedUnits.some(u => 
    (u.unitId === 'oil_tanker' || u.unitId === 'm4_tank') && !u.isDestroyed
  )
  
  if (hasGiantAirship && hasAtkBuffUnit && bonus > 0) {
    bonus *= 2  // ãƒœãƒ¼ãƒŠã‚¹å€¤ã‚’2å€ã«ï¼ˆ0.3â†’0.6ã€0.5â†’1.0ã€0.8â†’1.6ï¼‰
  }
  
  return bonus
}

/**
 * é˜²å¾¡åŠ›è£œæ­£ã‚’è¨ˆç®—
 * @param placedUnits - é…ç½®éƒ¨éšŠãƒªã‚¹ãƒˆ
 * @returns number - é˜²å¾¡åŠ›ã®è£œæ­£å€ç‡
 */
function calculateDefenseBonus(placedUnits: PlacedUnit[]): number {
  let bonus = 0
  
  // æ¶ˆé˜²è»Š: +20%
  if (placedUnits.some(u => u.unitId === 'fire_truck' && !u.isDestroyed)) {
    bonus += 0.2
  }
  
  // ãƒ€ãƒ³ãƒ—: +30%
  if (placedUnits.some(u => u.unitId === 'dump_truck' && !u.isDestroyed)) {
    bonus += 0.3
  }
  
  // å·¨å¤§é£›è¡Œè‰‡: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹UPåŠ¹æœå€¤ã‚’2å€ã«ï¼ˆä¾‹ï¼š30%â†’60%ï¼‰
  const hasGiantAirship = placedUnits.some(u => u.unitId === 'giant_airship' && !u.isDestroyed)
  const hasDefBuffUnit = placedUnits.some(u => 
    (u.unitId === 'fire_truck' || u.unitId === 'dump_truck') && !u.isDestroyed
  )
  
  if (hasGiantAirship && hasDefBuffUnit && bonus > 0) {
    bonus *= 2  // ãƒœãƒ¼ãƒŠã‚¹å€¤ã‚’2å€ã«ï¼ˆ0.2â†’0.4ã€0.3â†’0.6ã€0.5â†’1.0ï¼‰
  }
  
  return bonus
}
```

### ç›´æ¥ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—

```typescript
/**
 * ç›´æ¥æ”»æ’ƒï¼ˆéƒ¨éšŠã«å¤–ã‚ŒãŸæ™‚ï¼‰ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—
 * @param attacker - æ”»æ’ƒå´ï¼ˆ'player' or 'enemy'ï¼‰
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @returns number - ãƒ€ãƒ¡ãƒ¼ã‚¸é‡
 */
function calculateDirectDamage(attacker: 'player' | 'enemy', state: BattleState): number {
  // 1. æ”»æ’ƒå´ã¨é˜²å¾¡å´ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const attackerStats = attacker === 'player' ? state.playerStats : state.enemyStats
  const defenderStats = attacker === 'player' ? state.enemyStats : state.playerStats
  const attackerUnits = attacker === 'player' 
    ? state.playerField.placedUnits 
    : state.enemyField.placedUnits
  const defenderUnits = attacker === 'player' 
    ? state.enemyField.placedUnits 
    : state.playerField.placedUnits
  
  // 2. åŸºæœ¬æ”»æ’ƒåŠ›ã‚’å–å¾—
  const baseAT = attackerStats.AT
  const baseDF = defenderStats.DF
  
  // 3. ãƒ©ãƒ³ãƒ€ãƒ ãƒ–ãƒ¬ï¼ˆÂ±10%ï¼‰
  const randomFactor = 1 + (Math.random() * 0.2 - 0.1)  // 0.9 ~ 1.1
  
  // 4. æ”»æ’ƒåŠ›è£œæ­£ã‚’è¨ˆç®—
  const atkBonus = calculateAttackBonus(attackerUnits)
  const totalAT = baseAT * (1 + atkBonus) * randomFactor
  
  // 5. é˜²å¾¡åŠ›è£œæ­£ã‚’è¨ˆç®—
  const defBonus = calculateDefenseBonus(defenderUnits)
  const totalDF = baseDF * (1 + defBonus)
  
  // 6. æœ€çµ‚ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ï¼ˆæœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸ä¿è¨¼ï¼‰
  const finalDamage = Math.max(1, Math.floor(totalAT - totalDF))
  
  return finalDamage
}

/**
 * ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’é©ç”¨
 * @param target - å¯¾è±¡ï¼ˆ'player' or 'enemy'ï¼‰
 * @param damage - ãƒ€ãƒ¡ãƒ¼ã‚¸é‡
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 */
function applyDirectDamage(target: 'player' | 'enemy', damage: number, state: BattleState): void {
  if (target === 'player') {
    state.playerStats.HP = Math.max(0, state.playerStats.HP - damage)
  } else {
    state.enemyStats.HP = Math.max(0, state.enemyStats.HP - damage)
  }
}
```

---

## ç‰¹æ®Šæ”»æ’ƒãƒ­ã‚¸ãƒƒã‚¯

### SPæ¶ˆè²»ã‚³ã‚¹ãƒˆè¨ˆç®—

```typescript
/**
 * ç‰¹æ®Šæ”»æ’ƒã®SPæ¶ˆè²»é‡ã‚’è¨ˆç®—ï¼ˆã‚¬ãƒ—ãƒªãƒ¼ãƒå°‚ç”¨ã®å¢—åŠ ç³»å¯¾å¿œï¼‰
 * @param unitId - éƒ¨éšŠID
 * @param usageCount - ä½¿ç”¨å›æ•°
 * @param unit - éƒ¨éšŠãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
 * @returns number - æ¶ˆè²»SP
 */
function getSpecialAttackCost(unitId: string, usageCount: number, unit: Unit): number {
  if (!unit.specialAttack) {
    throw new Error(`Unit ${unitId} has no special attack`)
  }
  
  const baseSpCost = unit.specialAttack.baseSpCost || unit.specialAttack.spCost
  const spIncrease = unit.specialAttack.spIncrease || 0
  
  // ä½¿ç”¨å›æ•°ã«å¿œã˜ã¦å¢—åŠ 
  return baseSpCost + (spIncrease * usageCount)
}

// ä¾‹:
// èª˜å°å¼¾: baseSpCost=16, spIncrease=8
// 1å›ç›®: 16
// 2å›ç›®: 16 + 8 = 24
// 3å›ç›®: 16 + 8*2 = 32
```

### åå­—çˆ†æ’ƒï¼ˆãƒãƒªã‚¢ãƒ¼ï¼‰

```typescript
/**
 * åå­—çˆ†æ’ƒã®æ”»æ’ƒç¯„å›²ã‚’å–å¾—
 * @param center - ä¸­å¿ƒåº§æ¨™
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @param rangeMultiplier - ç¯„å›²å€ç‡ï¼ˆèˆªç©ºæ¯è‰¦åŠ¹æœç”¨ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1ï¼‰
 * @returns Position[] - æ”»æ’ƒå¯¾è±¡ã‚»ãƒ«ã®é…åˆ—
 */
function getCrossBombingTargets(
  center: Position,
  field: Field,
  rangeMultiplier: number = 1
): Position[] {
  const targets: Position[] = [center]  // ä¸­å¿ƒã‚’å«ã‚€
  const baseRange = 3  // åŸºæœ¬ç¯„å›²ï¼šä¸Šä¸‹å·¦å³3ãƒã‚¹
  const range = baseRange * rangeMultiplier  // èˆªç©ºæ¯è‰¦ãŒã‚ã‚Œã°6ãƒã‚¹
  
  // ä¸Šæ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x, y: center.y - i }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  // ä¸‹æ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x, y: center.y + i }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  // å·¦æ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x - i, y: center.y }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  // å³æ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x + i, y: center.y }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  return targets
}
```

### ç¸¦åˆ—çˆ†æ’ƒï¼ˆF15æˆ¦é—˜æ©Ÿï¼‰

```typescript
/**
 * ç¸¦åˆ—çˆ†æ’ƒã®æ”»æ’ƒç¯„å›²ã‚’å–å¾—
 * @param position - æ”»æ’ƒåº§æ¨™
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns Position[] - æ”»æ’ƒå¯¾è±¡ã‚»ãƒ«ã®é…åˆ—
 */
function getColumnBombingTargets(position: Position, field: Field): Position[] {
  const targets: Position[] = []
  
  // åŒã˜xåº§æ¨™ã®å…¨yåº§æ¨™ã‚’æ”»æ’ƒ
  for (let y = 0; y < field.size.height; y++) {
    targets.push({ x: position.x, y })
  }
  
  return targets
}
```

### æ°´å¹³çˆ†æ’ƒï¼ˆæˆ¦è‰¦ï¼‰

```typescript
/**
 * æ°´å¹³çˆ†æ’ƒã®æ”»æ’ƒç¯„å›²ã‚’å–å¾—
 * @param position - æ”»æ’ƒåº§æ¨™
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns Position[] - æ”»æ’ƒå¯¾è±¡ã‚»ãƒ«ã®é…åˆ—
 */
function getRowBombingTargets(position: Position, field: Field): Position[] {
  const targets: Position[] = []
  
  // åŒã˜yåº§æ¨™ã®å…¨xåº§æ¨™ã‚’æ”»æ’ƒ
  for (let x = 0; x < field.size.width; x++) {
    targets.push({ x, y: position.y })
  }
  
  return targets
}
```

### é›†ä¸­ç ²ç«ï¼ˆM60æˆ¦è»Š - ã‚¸ãƒ£ãƒƒã‚¯å°‚ç”¨ï¼‰

```typescript
/**
 * é›†ä¸­ç ²ç«ã®å‡¦ç†
 * é¸ã‚“ã ãƒã‚¹ã«æ•µè‰¦ãŒãªã„å ´åˆï¼ˆMISSæ™‚ï¼‰ã®ã¿3å›é€£ç¶šæ”»æ’ƒã‚’å®Ÿè¡Œ
 * æ•µè‰¦ãŒã‚ã‚‹å ´åˆï¼ˆHITæ™‚ï¼‰ã¯é€šå¸¸é€šã‚Šå‡¦ç†ã—ã¦ã‚¿ãƒ¼ãƒ³çµ‚äº†
 * @param initialPosition - æœ€åˆã®æ”»æ’ƒåº§æ¨™
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @returns AttackResult[] - å„æ”»æ’ƒã®çµæœé…åˆ—
 */
function executeBurstFire(initialPosition: Position, state: BattleState): AttackResult[] {
  const results: AttackResult[] = []
  const targetField = state.turn === Turn.PLAYER ? state.enemyField : state.playerField
  
  // 1å›ç›®ã®æ”»æ’ƒåˆ¤å®š
  const firstHit = isHit(initialPosition, targetField)
  
  if (firstHit) {
    // æ•µè‰¦ãŒã‚ã‚‹å ´åˆã¯é€šå¸¸HITå‡¦ç†ã®ã¿
    const result = executeAttack(initialPosition, state)
    results.push(result)
    return results  // HITæ™‚ã¯1å›ã®ã¿ã§ã‚¿ãƒ¼ãƒ³çµ‚äº†
  }
  
  // MISSæ™‚ã®ã¿3å›æ”»æ’ƒ
  // 1å›ç›®
  const firstResult = executeAttack(initialPosition, state)
  results.push(firstResult)
  
  // 2å›ç›®
  const secondPos = getRandomUnexploredCell(state.enemyField)
  if (secondPos) {
    const secondResult = executeAttack(secondPos, state)
    results.push(secondResult)
  }
  
  // 3å›ç›®
  const thirdPos = getRandomUnexploredCell(state.enemyField)
  if (thirdPos) {
    const thirdResult = executeAttack(thirdPos, state)
    results.push(thirdResult)
  }
  
  return results
}
```

### ç„¡å·®åˆ¥æ”»æ’ƒï¼ˆã‚¢ãƒ‘ãƒƒãƒ - ã‚¸ãƒ£ãƒƒã‚¯å°‚ç”¨ï¼‰

```typescript
/**
 * ç„¡å·®åˆ¥æ”»æ’ƒã‚’é–‹å§‹
 * 10ç§’é–“é€£å°„å¯èƒ½ãªçŠ¶æ…‹ã«ã™ã‚‹
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 */
function startRapidFire(state: BattleState): void {
  const duration = 10000  // 10ç§’ï¼ˆãƒŸãƒªç§’ï¼‰
  const startTime = Date.now()
  
  state.activeSpecialAttack = {
    type: SpecialAttackType.RAPID,
    startTime,
    endTime: startTime + duration
  }
}

/**
 * ç„¡å·®åˆ¥æ”»æ’ƒãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @returns boolean - æœ‰åŠ¹ãªã‚‰true
 */
function isRapidFireActive(state: BattleState): boolean {
  if (state.activeSpecialAttack.type !== SpecialAttackType.RAPID) {
    return false
  }
  
  const now = Date.now()
  return now <= (state.activeSpecialAttack.endTime || 0)
}
```

### èª˜å°å¼¾ï¼ˆè‡ªèµ°å¯¾ç©ºãƒŸã‚µã‚¤ãƒ« - ã‚¬ãƒ—ãƒªãƒ¼ãƒå°‚ç”¨ï¼‰

```typescript
/**
 * èª˜å°å¼¾ã®å‡¦ç†
 * æ•µã®éƒ¨éšŠãŒé…ç½®ã•ã‚Œã¦ã„ã‚‹ãƒã‚¹ã‚’1ã¤è‡ªå‹•ã§ç™ºè¦‹
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns Position | null - ç™ºè¦‹ã—ãŸãƒã‚¹ã®åº§æ¨™ï¼ˆãªã‘ã‚Œã°nullï¼‰
 */
function executeAutoDetect(field: Field): Position | null {
  // æœªæ¢ç´¢ã‹ã¤éƒ¨éšŠãŒé…ç½®ã•ã‚Œã¦ã„ã‚‹ã‚»ãƒ«ã‚’åé›†
  const unexploredUnits: Position[] = []
  
  for (let y = 0; y < field.size.height; y++) {
    for (let x = 0; x < field.size.width; x++) {
      const cell = field.cells[y][x]
      if (cell.state === CellState.UNEXPLORED && cell.unitId) {
        unexploredUnits.push({ x, y })
      }
    }
  }
  
  // ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤é¸æŠ
  if (unexploredUnits.length === 0) {
    return null
  }
  
  const randomIndex = Math.floor(Math.random() * unexploredUnits.length)
  const target = unexploredUnits[randomIndex]
  
  // è‡ªå‹•ã§HITå‡¦ç†
  processHit(target, field)
  
  return target
}
```

### å¦¨å®³å·¥ä½œï¼ˆã‚¢ãƒ‘ãƒƒãƒ - ã‚¬ãƒ—ãƒªãƒ¼ãƒå°‚ç”¨ï¼‰

```typescript
/**
 * å¦¨å®³å·¥ä½œã®å‡¦ç†
 * ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã‚’å¼·åˆ¶çš„ã«å¥ªå–
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 */
function executeStealTurn(state: BattleState): void {
  // ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã‚’å¼·åˆ¶çµ‚äº†
  // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
  // ï¼ˆå®Ÿéš›ã«ã¯ã‚¿ãƒ¼ãƒ³ã‚’å¤‰æ›´ã—ãªã„ã“ã¨ã§å®Ÿç¾ï¼‰
  
  // ç‰¹æ®Šæ”»æ’ƒå¾Œã¯é€šå¸¸ã‚¿ãƒ¼ãƒ³äº¤ä»£ã™ã‚‹ãŒã€
  // ã“ã®åŠ¹æœã§ã¯äº¤ä»£ã›ãšã«é€£ç¶šã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³ã«ã™ã‚‹
  state.turn = Turn.PLAYER
  state.canContinueAttack = true
}
```

### èˆªç©ºæ¯è‰¦ã®åŠ¹æœï¼ˆå…¨ç‰¹æ®Šæ”»æ’ƒç¯„å›²Ã—2ï¼‰

```typescript
/**
 * èˆªç©ºæ¯è‰¦ã®åŠ¹æœã‚’é©ç”¨
 * å…¨ç‰¹æ®Šæ”»æ’ƒã®ç¯„å›²ã‚’2å€ã«ã™ã‚‹
 * @param placedUnits - é…ç½®éƒ¨éšŠãƒªã‚¹ãƒˆ
 * @returns number - å€ç‡ï¼ˆ1 or 2ï¼‰
 */
function getSpecialAttackRangeMultiplier(placedUnits: PlacedUnit[]): number {
  const hasCarrier = placedUnits.some(u => u.unitId === 'aircraft_carrier' && !u.isDestroyed)
  return hasCarrier ? 2 : 1
}

// ä½¿ç”¨ä¾‹ï¼šåå­—çˆ†æ’ƒ
function getCrossBombingTargets(center: Position, field: Field, multiplier: number): Position[] {
  const targets: Position[] = [center]  // ä¸­å¿ƒã‚’å«ã‚€
  const baseRange = 3  // åŸºæœ¬ç¯„å›²ï¼šä¸Šä¸‹å·¦å³3ãƒã‚¹
  const range = baseRange * multiplier  // èˆªç©ºæ¯è‰¦ãŒã‚ã‚Œã°6ãƒã‚¹
  
  // ä¸Šæ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x, y: center.y - i }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  // ä¸‹æ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x, y: center.y + i }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  // å·¦æ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x - i, y: center.y }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  // å³æ–¹å‘
  for (let i = 1; i <= range; i++) {
    const pos = { x: center.x + i, y: center.y }
    if (isValidPosition(pos, field.size)) {
      targets.push(pos)
    }
  }
  
  return targets
}
```

---

## åœ°é›·ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯

### åœ°é›·ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ç™ºå‹•

```typescript
/**
 * åœ°é›·ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼æ”»æ’ƒã‚’ç™ºå‹•
 * @param attacker - åœ°é›·ã‚’è¸ã‚“ã å´ï¼ˆ'player' or 'enemy'ï¼‰
 * @param landmineCount - è¸ã‚“ã åœ°é›·ã®æ•°
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 */
function triggerLandmineCounter(
  attacker: 'player' | 'enemy',
  landmineCount: number,
  state: BattleState
): void {
  // 1. æ”»æ’ƒå´ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å–å¾—
  const targetField = attacker === 'player' ? state.playerField : state.enemyField
  
  // 2. è¸ã‚“ã åœ°é›·ã®æ•°ã ã‘ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼æ”»æ’ƒ
  for (let i = 0; i < landmineCount; i++) {
    // ãƒ©ãƒ³ãƒ€ãƒ ã«1ãƒã‚¹é¸æŠï¼ˆæœªæ”»æ’ƒã®ãƒã‚¹ã‹ã‚‰ï¼‰
    const target = getRandomUnexploredCell(targetField)
    
    if (target) {
      // 3. è‡ªå‹•æ”»æ’ƒï¼ˆå›ºå®š1ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
      const hit = isHit(target, targetField)
      
      if (hit) {
        processHit(target, targetField)
        // éƒ¨éšŠã«HITã—ã¦ã‚‚é€£ç¶šæ”»æ’ƒæ¨©ãªã—
      } else {
        processMiss(target, targetField)
        // å›ºå®š1ãƒ€ãƒ¡ãƒ¼ã‚¸
        if (attacker === 'player') {
          state.playerStats.HP = Math.max(0, state.playerStats.HP - 1)
        } else {
          state.enemyStats.HP = Math.max(0, state.enemyStats.HP - 1)
        }
      }
    }
  }
  
  // 4. ã‚¿ãƒ¼ãƒ³å¼·åˆ¶äº¤ä»£ï¼ˆã™ã¹ã¦ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼çµ‚äº†å¾Œï¼‰
  state.turn = switchTurn(state.turn)
  resetContinueAttack(state)
}

/**
 * ãƒ©ãƒ³ãƒ€ãƒ ã«æœªæ”»æ’ƒã®ã‚»ãƒ«ã‚’å–å¾—
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns Position | null - åº§æ¨™ï¼ˆãªã‘ã‚Œã°nullï¼‰
 */
function getRandomUnexploredCell(field: Field): Position | null {
  const unexplored: Position[] = []
  
  for (let y = 0; y < field.size.height; y++) {
    for (let x = 0; x < field.size.width; x++) {
      if (field.cells[y][x].state === CellState.UNEXPLORED) {
        unexplored.push({ x, y })
      }
    }
  }
  
  if (unexplored.length === 0) {
    return null
  }
  
  const randomIndex = Math.floor(Math.random() * unexplored.length)
  return unexplored[randomIndex]
}
```

### ç‰¹æ®Šæ”»æ’ƒæ™‚ã®åœ°é›·ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å‡¦ç†

```typescript
/**
 * ç‰¹æ®Šæ”»æ’ƒã§ã®åœ°é›·è¸ç ´ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
 * @param attackedPositions - æ”»æ’ƒã—ãŸåº§æ¨™ã®é…åˆ—
 * @param field - å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
 * @returns number - è¸ã‚“ã åœ°é›·ã®æ•°
 */
function countTriggeredLandmines(
  attackedPositions: Position[],
  field: Field
): number {
  let landmineCount = 0
  
  for (const pos of attackedPositions) {
    const cell = field.cells[pos.y][pos.x]
    
    // åœ°é›·ã‚’è¸ã‚“ã å ´åˆ
    if (cell.unitId === 'mine' && cell.state === CellState.HIT) {
      const unit = field.placedUnits.find(u => u.unitId === 'mine' && !u.isDestroyed)
      if (unit && unit.occupiedCells.some(c => c.x === pos.x && c.y === pos.y)) {
        landmineCount++
      }
    }
  }
  
  return landmineCount
}
```


---

## å›å¾©ãƒ­ã‚¸ãƒƒã‚¯

### HPå›å¾©å‡¦ç†

```typescript
/**
 * HPå›å¾©ã‚’å®Ÿè¡Œ
 * @param target - å›å¾©å¯¾è±¡ï¼ˆ'player' or 'enemy'ï¼‰
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @returns HealResult - å›å¾©çµæœ
 */
interface HealResult {
  success: boolean     // æˆåŠŸã—ãŸã‹ã©ã†ã‹
  healAmount: number   // å®Ÿéš›ã®å›å¾©é‡
  spCost: number       // æ¶ˆè²»ã—ãŸSP
  reason?: string      // å¤±æ•—ç†ç”±
}

function executeHeal(target: 'player' | 'enemy', state: BattleState): HealResult {
  const stats = target === 'player' ? state.playerStats : state.enemyStats
  
  // 1. å›å¾©é‡ã‚’è¨ˆç®—ï¼ˆæœ€å¤§HPã®30%ï¼‰
  const maxHealAmount = Math.floor(stats.maxHP * 0.3)
  
  // 2. å®Ÿéš›ã«å›å¾©å¯èƒ½ãªé‡ã‚’è¨ˆç®—
  const currentHP = stats.HP
  const missingHP = stats.maxHP - currentHP
  const actualHealAmount = Math.min(maxHealAmount, missingHP)
  
  // 3. å›å¾©å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
  if (actualHealAmount < maxHealAmount) {
    return {
      success: false,
      healAmount: 0,
      spCost: 0,
      reason: `æœ€ä½${maxHealAmount}HPå›å¾©ã§ãã¾ã›ã‚“ï¼ˆæ®‹ã‚Šå›å¾©å¯èƒ½é‡: ${missingHP}HPï¼‰`
    }
  }
  
  // 4. SPæ¶ˆè²»é‡ã‚’è¨ˆç®—ï¼ˆ1HP = 1SPï¼‰
  const spCost = actualHealAmount
  
  // 5. SPãŒè¶³ã‚Šã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  if (stats.SP < spCost) {
    return {
      success: false,
      healAmount: 0,
      spCost: 0,
      reason: `SPãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦: ${spCost}SPã€æ‰€æŒ: ${stats.SP}SPï¼‰`
    }
  }
  
  // 6. å›å¾©ã‚’å®Ÿè¡Œ
  stats.HP = Math.min(stats.maxHP, stats.HP + actualHealAmount)
  stats.SP -= spCost
  
  return {
    success: true,
    healAmount: actualHealAmount,
    spCost
  }
}

/**
 * å›å¾©å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
 * @param target - å›å¾©å¯¾è±¡ï¼ˆ'player' or 'enemy'ï¼‰
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @returns boolean - å›å¾©å¯èƒ½ãªã‚‰true
 */
function canHeal(target: 'player' | 'enemy', state: BattleState): boolean {
  const stats = target === 'player' ? state.playerStats : state.enemyStats
  const maxHealAmount = Math.floor(stats.maxHP * 0.3)
  const missingHP = stats.maxHP - stats.HP
  
  // æœ€ä½å›å¾©é‡ã‚’æº€ãŸã›ã‚‹ã‹ && SPãŒè¶³ã‚Šã‚‹ã‹
  return missingHP >= maxHealAmount && stats.SP >= maxHealAmount
}
```

### å›å¾©é‡ã®è¨ˆç®—ä¾‹

```
ä¾‹1: æœ€å¤§HP 100ã€ç¾åœ¨HP 50ã®å ´åˆ
- å›å¾©é‡: 100 Ã— 0.3 = 30HP
- SPæ¶ˆè²»: 30SP
- å›å¾©å¾ŒHP: 80HP

ä¾‹2: æœ€å¤§HP 150ã€ç¾åœ¨HP 140ã®å ´åˆ
- å›å¾©é‡: 150 Ã— 0.3 = 45HPå¿…è¦
- å®Ÿéš›ã®å›å¾©å¯èƒ½é‡: 150 - 140 = 10HP
- çµæœ: å›å¾©ä¸å¯ï¼ˆ45HPå›å¾©ã§ããªã„ãŸã‚ï¼‰

ä¾‹3: æœ€å¤§HP 200ã€ç¾åœ¨HP 100ã€ç¾åœ¨SP 50ã®å ´åˆ
- å›å¾©é‡: 200 Ã— 0.3 = 60HP
- SPæ¶ˆè²»: 60SPå¿…è¦
- çµæœ: å›å¾©ä¸å¯ï¼ˆSPãŒ10ä¸è¶³ï¼‰
```

---

## å‹æ•—åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯

### å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯

```typescript
/**
 * å‹æ•—ã‚’åˆ¤å®š
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @returns 'player' | 'enemy' | null - å‹è€…ï¼ˆæ±ºç€ãªã—ã¯nullï¼‰
 */
function checkVictory(state: BattleState): 'player' | 'enemy' | null {
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‹åˆ©æ¡ä»¶
  // 1. æ•µã®HPãŒ0
  if (state.enemyStats.HP <= 0) {
    return 'player'
  }
  
  // 2. æ•µã®å…¨éƒ¨éšŠãŒç ´å£Š
  const enemyUnitsAllDestroyed = state.enemyField.placedUnits.every(u => u.isDestroyed)
  if (enemyUnitsAllDestroyed && state.enemyField.placedUnits.length > 0) {
    return 'player'
  }
  
  // æ•µå‹åˆ©æ¡ä»¶
  // 1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HPãŒ0
  if (state.playerStats.HP <= 0) {
    return 'enemy'
  }
  
  // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¨éƒ¨éšŠãŒç ´å£Š
  const playerUnitsAllDestroyed = state.playerField.placedUnits.every(u => u.isDestroyed)
  if (playerUnitsAllDestroyed && state.playerField.placedUnits.length > 0) {
    return 'enemy'
  }
  
  // æ±ºç€ãªã—
  return null
}
```

---

## çµŒé¨“å€¤ãƒ»å ±é…¬è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯

### çµŒé¨“å€¤è¨ˆç®—

```typescript
/**
 * éƒ¨éšŠç ´å£Šæ™‚ã®çµŒé¨“å€¤ã‚’è¨ˆç®—
 * @param unitId - ç ´å£Šã—ãŸéƒ¨éšŠID
 * @param units - éƒ¨éšŠãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
 * @returns number - çµŒé¨“å€¤
 */
function calculateDestroyExp(unitId: string, units: Unit[]): number {
  const unit = units.find(u => u.id === unitId)
  if (!unit) return 0
  
  // 1ãƒã‚¹ã‚ãŸã‚Š5 EXP
  return unit.size * 5
}

/**
 * æˆ¦é—˜çµ‚äº†æ™‚ã®æœ€çµ‚çµŒé¨“å€¤ã‚’è¨ˆç®—
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @param baseExp - åŸºæœ¬çµŒé¨“å€¤ï¼ˆç ´å£Šã—ãŸéƒ¨éšŠã®åˆè¨ˆï¼‰
 * @returns number - æœ€çµ‚çµŒé¨“å€¤
 */
function calculateFinalExp(state: BattleState, baseExp: number): number {
  // 1. å æœ‰ç‡ãƒœãƒ¼ãƒŠã‚¹
  const totalCells = state.playerField.size.width * state.playerField.size.height
  const occupiedCells = state.playerField.placedUnits.reduce((sum, u) => sum + u.occupiedCells.length, 0)
  const occupancyRate = occupiedCells / totalCells
  const occupancyBonus = baseExp * occupancyRate * 0.5
  
  let finalExp = baseExp + occupancyBonus
  
  // 2. æ—…å®¢æ©Ÿãƒœãƒ¼ãƒŠã‚¹ï¼ˆç”Ÿå­˜ã—ã¦ã„ã‚Œã°Ã—1.5ï¼‰
  const hasPassengerPlane = state.playerField.placedUnits.some(u => 
    u.unitId === 'passenger_plane' && !u.isDestroyed
  )
  
  if (hasPassengerPlane) {
    finalExp *= 1.5
  }
  
  return Math.floor(finalExp)
}
```

### å ±é…¬è¨ˆç®—

```typescript
/**
 * æˆ¦é—˜çµ‚äº†æ™‚ã®å ±é…¬ã‚’è¨ˆç®—
 * @param state - æˆ¦é—˜çŠ¶æ…‹
 * @param winner - å‹è€…
 * @returns BattleResult - æˆ¦é—˜çµæœ
 */
function calculateBattleResult(state: BattleState, winner: 'player' | 'enemy'): BattleResult {
  const isVictory = winner === 'player'
  
  // ç ´å£Šã—ãŸéƒ¨éšŠæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
  const unitsDestroyed = state.enemyField.placedUnits.filter(u => u.isDestroyed).length
  const unitsLost = state.playerField.placedUnits.filter(u => u.isDestroyed).length
  
  // åŸºæœ¬çµŒé¨“å€¤è¨ˆç®—
  let baseExp = 0
  for (const unit of state.enemyField.placedUnits) {
    if (unit.isDestroyed) {
      baseExp += calculateDestroyExp(unit.unitId, [])  // UNITSå®šæ•°ã‹ã‚‰å–å¾—
    }
  }
  
  const totalExp = calculateFinalExp(state, baseExp)
  
  // è³é‡‘è¨ˆç®—ï¼ˆå‹åˆ©æ™‚ã®ã¿ï¼‰
  let totalReward = 0
  let hpBonus = 0
  let unitsBonus = 0
  
  if (isVictory) {
    const baseReward = state.enemy.baseReward
    
    // HPæ®‹å­˜ç‡ï¼ˆmaxHPã‚’ä½¿ç”¨ï¼‰
    const hpRate = state.playerStats.HP / state.playerStats.maxHP
    hpBonus = Math.floor(baseReward * hpRate * 0.5)
    
    // éƒ¨éšŠæ®‹å­˜ç‡
    const totalUnits = state.playerField.placedUnits.length
    const remainingUnits = totalUnits - unitsLost
    const unitsRate = remainingUnits / totalUnits
    unitsBonus = Math.floor(baseReward * unitsRate * 0.3)
    
    totalReward = Math.floor(baseReward + hpBonus + unitsBonus)
  }
  
  return {
    isVictory,
    totalDamageDealt: 0,  // å±¥æ­´ã‹ã‚‰è¨ˆç®—
    totalDamageReceived: 0,  // å±¥æ­´ã‹ã‚‰è¨ˆç®—
    unitsDestroyed,
    unitsLost,
    baseReward: state.enemy.baseReward,
    hpBonus,
    unitsBonus,
    totalReward,
    baseExp,
    occupancyBonus: 0,  // calculateFinalExpã§è¨ˆç®—æ¸ˆã¿
    passengerBonus: false,  // æ—…å®¢æ©Ÿã®æœ‰ç„¡
    totalExp,
    remainingHP: state.playerStats.HP,
    remainingUnits: state.playerField.placedUnits.length - unitsLost
  }
}
```

### HPå›å¾©ã‚³ã‚¹ãƒˆè¨ˆç®—

```typescript
/**
 * HPå›å¾©ã«ã‹ã‹ã‚‹ã‚³ã‚¹ãƒˆã‚’è¨ˆç®—
 * @param healAmount - å›å¾©é‡
 * @returns number - ã‚³ã‚¹ãƒˆ
 */
function calculateHealCost(healAmount: number): number {
  return healAmount * 2
}

// ä¾‹:
// 100HPå›å¾© = 200å††
// æœ€å¤§HPã¾ã§å›å¾© = (maxHP - currentHP) * 2
```

---

## ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°

### ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ

```typescript
/**
 * é…åˆ—ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«è¦ç´ ã‚’é¸æŠ
 * @param array - å¯¾è±¡é…åˆ—
 * @returns T - é¸æŠã•ã‚ŒãŸè¦ç´ 
 */
function randomChoice<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)]
}
```

### ç¯„å›²ãƒã‚§ãƒƒã‚¯

```typescript
/**
 * å€¤ãŒç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
 * @param value - ãƒã‚§ãƒƒã‚¯ã™ã‚‹å€¤
 * @param min - æœ€å°å€¤
 * @param max - æœ€å¤§å€¤
 * @returns boolean - ç¯„å›²å†…ãªã‚‰true
 */
function isInRange(value: number, min: number, max: number): boolean {
  return value >= min && value <= max
}
```

### ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼

```typescript
/**
 * ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
 * @param obj - ã‚³ãƒ”ãƒ¼å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @returns T - ã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function deepCopy<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj))
}
```

---

## ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆé›†

### æ”»æ’ƒå‡¦ç†ã®å…¨ä½“ãƒ•ãƒ­ãƒ¼

```
é–‹å§‹: attack(position)
  â†“
åº§æ¨™ã®æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯
  â†“ NO â†’ return ã‚¨ãƒ©ãƒ¼
  â†“ YES
HITåˆ¤å®š: isHit(position, field)
  â†“
  â”œâ”€â”€ YES (HIT)
  â”‚     â†“
  â”‚   processHit(position, field)
  â”‚     â†“
  â”‚   éƒ¨éšŠç ´å£Šãƒã‚§ãƒƒã‚¯
  â”‚     â†“
  â”‚     â”œâ”€â”€ ç ´å£Šå®Œäº†
  â”‚     â”‚     â†“
  â”‚     â”‚   çµŒé¨“å€¤ä»˜ä¸
  â”‚     â”‚     â†“
  â”‚     â”‚   åœ°é›·åˆ¤å®š
  â”‚     â”‚     â†“
  â”‚     â”‚     â”œâ”€â”€ åœ°é›·
  â”‚     â”‚     â”‚     â†“
  â”‚     â”‚     â”‚   triggerLandmineCounter()
  â”‚     â”‚     â”‚     â†“
  â”‚     â”‚     â”‚   return { canContinue: false }
  â”‚     â”‚     â”‚
  â”‚     â”‚     â””â”€â”€ é€šå¸¸éƒ¨éšŠ
  â”‚     â”‚           â†“
  â”‚     â”‚         é€£ç¶šæ”»æ’ƒæ¨©ä»˜ä¸
  â”‚     â”‚           â†“
  â”‚     â”‚         return { canContinue: true }
  â”‚     â”‚
  â”‚     â””â”€â”€ æœªç ´å£Š
  â”‚           â†“
  â”‚         é€£ç¶šæ”»æ’ƒæ¨©ä»˜ä¸
  â”‚           â†“
  â”‚         return { canContinue: true }
  â”‚
  â””â”€â”€ NO (MISS)
        â†“
      processMiss(position, field)
        â†“
      ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—: calculateDirectDamage()
        â†“
      ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨: applyDirectDamage()
        â†“
      ã‚¿ãƒ¼ãƒ³äº¤ä»£
        â†“
      return { canContinue: false }
```

### ç‰¹æ®Šæ”»æ’ƒãƒ•ãƒ­ãƒ¼

```
ç‰¹æ®Šæ”»æ’ƒãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
  â†“
SPååˆ†ï¼Ÿ
  â†“ NO â†’ ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
  â†“ YES
ç‰¹æ®Šæ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®š
  â†“
  â”œâ”€â”€ åå­—çˆ†æ’ƒ
  â”‚     â†“
  â”‚   getCrossBombingTargets()
  â”‚     â†“
  â”‚   å„ã‚»ãƒ«ã«æ”»æ’ƒå®Ÿè¡Œ
  â”‚     â†“
  â”‚   SPæ¶ˆè²»
  â”‚     â†“
  â”‚   ã‚¿ãƒ¼ãƒ³äº¤ä»£
  â”‚
  â”œâ”€â”€ ç¸¦åˆ—/æ°´å¹³çˆ†æ’ƒ
  â”‚     â†“
  â”‚   ï¼ˆåŒæ§˜ã®å‡¦ç†ï¼‰
  â”‚
  â”œâ”€â”€ é›†ä¸­ç ²ç«
  â”‚     â†“
  â”‚   1å›ç›®æ”»æ’ƒ
  â”‚     â†“
  â”‚   MISSï¼Ÿ
  â”‚     â†“ YES
  â”‚     2ï½3å›ç›®è‡ªå‹•æ”»æ’ƒ
  â”‚
  â”œâ”€â”€ ç„¡å·®åˆ¥æ”»æ’ƒ
  â”‚     â†“
  â”‚   startRapidFire()
  â”‚     â†“
  â”‚   10ç§’é–“é€£å°„ãƒ¢ãƒ¼ãƒ‰
  â”‚     â†“
  â”‚   æ™‚é–“åˆ‡ã‚Œã§ã‚¿ãƒ¼ãƒ³äº¤ä»£
  â”‚
  â”œâ”€â”€ èª˜å°å¼¾
  â”‚     â†“
  â”‚   executeAutoDetect()
  â”‚     â†“
  â”‚   è‡ªå‹•ã§éƒ¨éšŠç™ºè¦‹
  â”‚     â†“
  â”‚   ä½¿ç”¨å›æ•°+1ï¼ˆSPå¢—åŠ ï¼‰
  â”‚     â†“
  â”‚   ã‚¿ãƒ¼ãƒ³äº¤ä»£
  â”‚
  â””â”€â”€ å¦¨å®³å·¥ä½œ
        â†“
      executeStealTurn()
        â†“
      ã‚¿ãƒ¼ãƒ³å¥ªå–ï¼ˆäº¤ä»£ã—ãªã„ï¼‰
        â†“
      ä½¿ç”¨å›æ•°+1ï¼ˆSPå¢—åŠ ï¼‰
```

---

## ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### å˜ä½“ãƒ†ã‚¹ãƒˆé …ç›®

1. **ã‚°ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ **
   - ARãƒ¬ãƒ™ãƒ«1ï½11ã§æ­£ã—ã„ã‚µã‚¤ã‚ºãŒè¿”ã‚‹ã‹
   - åº§æ¨™ã®æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã‹

2. **éƒ¨éšŠé…ç½®**
   - å›è»¢å‡¦ç†ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã‹ï¼ˆ0, 90, 180, 270åº¦ï¼‰
   - å æœ‰ã‚»ãƒ«è¨ˆç®—ãŒæ­£ã—ã„ã‹
   - é…ç½®å¯èƒ½åˆ¤å®šãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã‹ï¼ˆé‡è¤‡ã€ç¯„å›²å¤–ï¼‰

3. **æ”»æ’ƒåˆ¤å®š**
   - HIT/MISSåˆ¤å®šãŒæ­£ã—ã„ã‹
   - éƒ¨éšŠç ´å£Šåˆ¤å®šãŒæ­£ã—ã„ã‹

4. **ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—**
   - åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ãŒæ­£ã—ã„ã‹
   - è£œæ­£è¨ˆç®—ãŒæ­£ã—ã„ã‹ï¼ˆæ”»æ’ƒåŠ›ã€é˜²å¾¡åŠ›ã€å·¨å¤§é£›è¡Œè‰‡ï¼‰
   - æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒä¿è¨¼ã•ã‚Œã‚‹ã‹

5. **ç‰¹æ®Šæ”»æ’ƒ**
   - å„ç‰¹æ®Šæ”»æ’ƒã®ç¯„å›²ãŒæ­£ã—ã„ã‹
   - SPæ¶ˆè²»ãŒæ­£ã—ã„ã‹ï¼ˆå¢—åŠ ç³»å«ã‚€ï¼‰

6. **å‹æ•—åˆ¤å®š**
   - HP0ã§æ­£ã—ãåˆ¤å®šã•ã‚Œã‚‹ã‹
   - å…¨éƒ¨éšŠç ´å£Šã§æ­£ã—ãåˆ¤å®šã•ã‚Œã‚‹ã‹

7. **çµŒé¨“å€¤ãƒ»å ±é…¬**
   - åŸºæœ¬çµŒé¨“å€¤è¨ˆç®—ãŒæ­£ã—ã„ã‹
   - ãƒœãƒ¼ãƒŠã‚¹è¨ˆç®—ãŒæ­£ã—ã„ã‹
   - å ±é…¬è¨ˆç®—ãŒæ­£ã—ã„ã‹

---

**ä»¥ä¸Šã€ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯è¨­è¨ˆæ›¸ï¼ˆç¬¬1ç‰ˆï¼‰**